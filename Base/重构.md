# 《重构，改善既有代码的设计》

## 第1章 重构，第一个案例

### 1.2

* 重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。

### 1.3

* 第一个步骤是找出代码的逻辑泥团并运用到 **Extract Method**。首先，得找出函数内的 **局部变量和参数**。任何 **不会** 被修改的变量都可以 **当成参数传入新的函数**。会被修改的变量需要格外小心，如果只有一个变量被修改，可以把它 **当作返回值**。

* 一些临时变量的使用，可以改成使用查询函数来进行，虽然这样可能带来性能上的代价，需要根据实际情况取舍。

### 1.4

* 最好不要在另一个对象的属性基础上运用 `switch` 语句，如果不得不使用，也应该在对象自己的数据上用。

## 第2章 重构原则

### 2.1

* 重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

* 重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

### 2.3

* 事不过三，三则重构

### 2.4

间接层的作用:

1. 允许逻辑共享。

2. 分开解释意图和实现。

3. 隔离变化。

4. 封装条件逻辑。

## 第3章 代码的坏味道

### 3.1 Duplicated Code(重复代码)

1. 最简单的就是同一个类的两个函数有相同表达式，这时候可以用 **Extract Method** 提炼出重复的代码，然后让这两个地点都调用提炼出来的那一段代码。

2. 两个互为兄弟的子类内含相同表达式，对两个类都使用 **Extract Method** ，然后对提炼出来的代码使用 **Pull Up Method**， 将它推入超类内。 
3. 如果两个毫不相关的类出现 **Duplicated Code** ，应该考虑把重复代码提炼到其中一个类或者第三个类。

### 3.2 Long Method(过长函数)

* 每当感觉需要以注释来说明点什么的时候，就把需要说明的东西写进一个独立的函数内，并以其 **用途** (并非实现手法)命名。只要函数名称能解释其用途，应该毫不犹豫的这么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。

### 3.3 Large Class(过大的类)

* 一个类内如果有太多实例变量或者代码，往往可以使用 **Extract Class** 和 **Extract Subclass** 提炼。

### 3.4 Long Parameter List(过长参数列)

* 对于太长的参数列，可以传入一个对象，让函数自己从对象中获取数据。

### 3.5 Divergent Change(发散式变化)

* 我们希望软件更容易被修改，一旦需要修改，我们希望能跳转到一个点，只在该处做修改，如果不能做到，就要注意了。如果某个类经常因为不同的原因在不同的方向上变化， **Divergent Change** 就出现了。针对某一外界变化的所有相应修改都应该只发生在单一类中，而这个类内的所有内容都应该反应此变化。

### 3.6 Shotgun Surgery(霰弹式修改)

* **Shotgun Surgery** 类似 **Divergent Change**。 如果遇到某种变化，都必须在许多不同的类内作出许多小的修改，你面临的坏味道就是 **Shotgun Surgery(霰弹式修改)**。

* **Divergent Change** 是指 “一个类受多种变化的影响”， **Shotgun Change** 则是指一种变化引发多个类相应修改。这两种情况下都应该整理代码，使“外界变化”与“需要修改的类”趋于一一对应。

### 3.7 Feature Envy(依恋情节)

* 一种经典的气味是：函数对某个类的兴趣高过自己所处类的兴趣。

### 3.8 Data Clumps(数据泥团)

* 总是绑在一起出现的数据应该拥有属于他们自己的对象，这样可以减少字段和参数的个数。

### 3.9 Primitive Obsession(基本类型偏执)

### 3.10 Switch Statements(Switch惊悚现身)

* 看到switch语句的时候，多数应该以多态替代，或者把分支的执行拆分成函数。

### 3.11 Parallel Inheritance Hierarchies(平行继承体系)

* 这是 **Shotgun Surgery** 的一种特殊情况。这种情况下每为一个类增加一个子类，也必须为另一个类增加一个子类。这种情况下一般策略是：让一个继承体系的实例引用另一个继承体系的实例。

### 3.12 Lazy Class(冗余类)

### 3.13 Speculative Generality(跨跨其谈未来性)

* 如果以总有一天需要做这事，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。如果函数或类的唯一用户是测试用例，那就飘出了这种坏味道。

### 3.14 Temporary Field(令人迷惑的暂时字段)

* 对象内某个实例变量仅为某种特定情况而设。这时候我们可以把这些变量和相关函数提炼到一个独立类中。

### 3.15 Message Chains(过度耦合的消息链)

* 如果用户向一个对象请求另一个对象，然后再向后者请求另一个对象……这就是消息链。我们可以把使用该对象的代码提炼到一个独立函数中，然后把这个函数推入消息链中。

### 3.16 Middle Man(中间人)

* 某个类接口有一半的函数都委托给其他类，这就是过度运用委托。这时候应该使用 **Remove Middle Man**，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以把它们放入调用端。 如果他们还有其他行为，可以使用 **Replace Delegation with Inheritance** 把它变成实责对象的子类，这样既可以拓展原对象的行为，又不必负担那么多的委托动作。

### 3.17 Inappropriate Intimacy(狎昵关系)

* 如果两个类花费太多时间去探究彼此的private成分，那么我们可以把他们分开或者提炼出共同点，创造一个新类。

### 3.18 Alternative Classes with Different Interfaces(异曲同工类)

* 如果两个函数做一件事但是有不同的签名，应该给他们重新命名，但这往往不够，还需要把某些行为移入类，直到两者的协议一致为止。

### 3.19 Incomplete Library Class(不完美的类库)

### 3.20 Data Class(纯稚的数据类)

### 3.21 Refused Bequest(被拒绝的遗赠)

* 如果子类不想继承超类的部分函数或者数据，按照传统说法，这常常意味着继承体系设计错误。

### 3.22 Comments(过多的注释)

* 过多的注释往往意味着代码设计糟糕，这个常常可以指示我们来寻找坏味道。

## 第4章 构筑测试体系

* 在少量比较容易出错的地方添加单元测试能够得到最高的收益，单元测试不能保证找出所有bug，但是能花合理时间找出大多数bug即可。

## 第5章 重构列表

### 5.1 重构的记录格式

每个重构手法都有如下五个部分：

* 名称。

* 简短概要  简单介绍此一重构手法的适用场景，以及它所做的事情。

* 动机  为你介绍“为什么需要这个重构” 和 “什么情况下不该使用这个重构”。

* 做法  简明扼要地一步一步介绍如何进行此一重构。

* 范例  以一个十分简单的例子说明此重构手法如何运作。

### 5.2 寻找引用点

* 不要盲目地查找-替换，应该检查每一个引用点，确保指向我们要替换的东西。

## 第6章 重新组织函数

### 6.1 Extract Method(提炼函数)

* **概要** ： 有一段代码可以被组织在一起并独立出来，将这段代码放入一个独立函数中，并让该函数名解释该函数的用途。

* **动机** ：1.每个函数粒度都很小的话，那么复用的机会更大。2.如果函数都是细粒度，更容易复写。

* **做法** ：

  1. 创建一个新函数，根据这个函数的意图来对它命名。（以它“做什么”来命名，而不是以它“怎么做”来命名）。

  2. 将提炼出的函数复制到新建的目标函数中。

  3. 仔细检查提炼出的代码，看其中是否引用了“作用域限于源函数”的变量。（包括局部变量和源函数参数）

  4. 检查是否有“仅用于被提炼代码段”的临时变量，如果有，在目标函数中将它们声明为临时变量。

  5. 检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，并将结果赋值给相关变量。如果很难这样做，或如果被修改的变量不止一个，就不能仅仅将这段代码原封不动的提炼出来。可能需要先使用 **Split Temporary Variable** ，然后再尝试提炼。也可以使用 **Replace Temp with Query** 将临时变量消灭掉。

  6. 将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。

  7. 处理完所有局部变量之后，进行编译。

  8. 在源函数中，将被提炼代码段替换为对目标函数的调用。

  9. 编译，测试。


### 6.2 Inline Method(内联函数)

* **概要** 在函数调用点插入函数本体，然后移除该函数

* **动机** 

  1. 有时候遇到某些函数，其内部代码和函数名称同样清晰易读

  2. 手上有一群组织不甚合理的函数，可以把它们内联到一个大型函数中，再从中提炼出组织合理的小型函数。

* **做法**

  1. 检查函数，确保它不具多态性

  2. 找出这个函数所有的调用点

  3. 将这个函数所有的调用点都替代为函数本体

  4. 编译测试

  5. 删除该函数的定义

### 6.3 Inline Temp(内联临时变量)

* **概要** 将所有对该对象的引用动作，替换为对它赋值那个表达式本身。

* **动机** 发现某个临时变量被赋予某个函数调用的返回值，如果这个临时变量妨碍了其他的重构手法，就应该内联化。

* **做法** 

  1. 检查给临时变量赋值的语句，确保右边的表达式没有副作用

  2. 如果这个变量未被声明为final，那就声明为final，然后编译，这可以检查该临时变量是否真的只被赋值一次。

  3. 找到该临时变量的所有引用点，将它们替换为“为临时变量赋值”的表达式。

  4. 每次修改后，编译并测试。

  5. 编译，测试。

### 6.4 Replace Temp With Query(以查询取代临时变量)

* **概要** 你的程序以一个临时变量保存某一表达式的运算结果。将这个表达式提炼到一个独立函数中。将这个临时变量的所有引用点替换为对新函数的调用，此后新函数就可被其他函数使用。

* **动机** 临时变量的问题是，它们是暂时的，而且只能在所属函数内使用，所以会驱使我们写出更长的函数。如果把临时变量替代为一个查询，那么同一个类中的所有函数都可以获得这份信息。**Replace Temp With Query** 往往是你运用 **Extract Method** 前必不可少的一个步骤。局部变量会使代码难以提炼，所以应该尽量替换为查询式。

* **做法** 

  1. 找出只被赋值一次的临时变量，如果某个临时变量被赋值超过一次，考虑使用 **Split Temporary Variable(128)** 将它分割成多个变量。

  2. 将该变量声明为final

  3. 编译，这可确保该临时变量的确只被赋值一次

  4. 将“对该临时变量赋值”之语句的等号右侧部分提炼到一个独立函数中。首相将函数声明为private，日后可能会发现有更多类需要使用它，那时放松对它的保护也很容易。确保提炼的函数无副作用，也就是说改函数并不修改任何对象内容。如果它有副作用，就对它进行 **Separate Query from Modifler(279)** 。

  5. 编译，测试

  6. 在该临时变量身上实施 **Inline Temp(119)** 。

运用此手法，可能会担心性能问题。但是现在先不管他，因为十有八九根本不会有任何影响，如果性能真的出了问题，也可以在优化时期解决它。代码组织良好，往往能发现更好的解决方案，如果性能太糟糕，要把临时变量放回去也是很简单的。

### 6.5 Introduce Explaining Variable(引入解释性变量)

* **概要** 你有一个复杂的表达式，将该复杂表达式（或其中一部分）放入一个临时变量，以此变量名称来解释表达式用途。

* **动机** 表达式有可能非常复杂而难以阅读。这种情况下，临时变量可以帮助你将表达式分解为比较容易管理的形式。

* **做法** 
  
  1. 声明一个final临时变量，将待分解的复杂表达式的一部分动作的运算结果赋给它。

  2. 将表达式中“运算结果”这一部分，替换为上述变量。

  3. 编译，测试。

  4. 重复上述过程，处理表达式的其他部分。

### 6.6 Split Temporary Variable(分解临时变量)

* **概要** 你的程序有某个临时变量被赋值一次，它既不是循环变量，也不被用于收集计算结果。 **针对每次赋值，创造一个独立的、对应的临时变量。**

* **动机** 有很多临时变量用于保存一段冗长代码的运算结果，以便稍后使用，这种变量应该只被赋值一次。如果它们被赋值超过一次，就意味着它们在函数中承担了一个以上的责任，这容易使阅读者糊涂。

* **做法** 

  1. 在待分解临时变量的生命及其第一次被赋值处，修改其名称。

  2. 将新的临时变量声明为final

  3. 以该临时变量的第二次赋值动作为界，修改此前对该临时变量的所有引用点，让它们引用新的临时变量。

  4. 在第二次赋值处，重新声明原先那个临时变量。

  5. 编译，测试。

  6. 逐次重复上述过程。每次都在声明处对临时变量改名，并修改下次赋值之前的引用点。

### 6.7 Remove Assignments To Parameters(移除对参数的赋值)

* **概要** 代码对一个参数进行赋值。以一个临时变量取代该参数的位置。

### 6.8 Replace Method With Method Object(以函数对象取代函数)

* **概要** 有一个大型函数，其中对局部变量的使用使得无法采用 **Extract Method** 。将这个函数放入一个单独的对象中，如此一来局部变量就成了对象内的字段。然后可以在同一个对象中将这个大型函数分解为很多小型函数。

* **做法**

  1. 建立一个新类，根据待处理函数的用途，为这个类命名

  2. 在这个新类中建立一个final对象，以保存原先大型函数所在的对象。我们将这个字段称为“源对象”。同时，针对原函数的每个临时变量和每个参数，在新类中建立一个对应的字段保存之。

  3. 在新类中建立一个构造函数，接受源对象及原函数的所有参数作为参数。

  4. 在新类中建立一个compute()函数。

  5. 将原函数的代码复制到compute()中。如果需要调用源对象的任何函数，请通过源对象字段调用。

  6. 编译。

  7. 将旧函数的函数本体改为这样一条语句：”创建上诉新类的一个对象，然后调用其中的compute()函数。

### 6.9 Substitute Algorithm(替换算法)

* **概要** 将函数本体替换为另一个算法

* **做法**

  1. 准备好另一个（替换用）算法，让它通过编译

  2. 针对现有测试，执行上述的新算法，如果结果与原本相同，重构结束

  3. 如果测试结果不同于原先，在测试和调试的过程中，以旧算法为比较参照标准。对每个测试用例，分别以新旧两种算法执行，并观察两者结果是否相同，这可以帮助你看到哪个测试用例出现麻烦，以及出现了怎么样的麻烦。

## 第7章 在对象之间搬移特性

### 7.1 Move Method(搬移函数)

* **概要** 程序中有一个函数与其所驻类之外的另一个类进行更多的交流，调用后者，或者被后者调用。在该函数最常引用的类中建立一个有类似行为的新函数。将旧函数变成一个单纯的委托函数，或将旧函数完全删除。

### 7.2 Move Field(搬运字段)

* **概要** 你的程序中，某个字段被所驻类之外的另一个类更多的用到。在目标类新建一个字段，修改源字段的所有用户，让它们改用新字段。
