# 《重构，改善既有代码的设计》

## 第1章 重构，第一个案例

### 1.2

* 重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。

### 1.3

* 第一个步骤是找出代码的逻辑泥团并运用到 **Extract Method**。首先，得找出函数内的 **局部变量和参数**。任何 **不会** 被修改的变量都可以 **当成参数传入新的函数**。会被修改的变量需要格外小心，如果只有一个变量被修改，可以把它 **当作返回值**。

* 一些临时变量的使用，可以改成使用查询函数来进行，虽然这样可能带来性能上的代价，需要根据实际情况取舍。

### 1.4

* 最好不要在另一个对象的属性基础上运用 `switch` 语句，如果不得不使用，也应该在对象自己的数据上用。

## 第2章 重构原则

### 2.1

* 重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

* 重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

### 2.3

* 事不过三，三则重构

### 2.4

间接层的作用:

1. 允许逻辑共享。

2. 分开解释意图和实现。

3. 隔离变化。

4. 封装条件逻辑。

## 第3章 代码的坏味道

### 3.1 Duplicated Code(重复代码)

1. 最简单的就是同一个类的两个函数有相同表达式，这时候可以用 **Extract Method** 提炼出重复的代码，然后让这两个地点都调用提炼出来的那一段代码。

2. 两个互为兄弟的子类内含相同表达式，对两个类都使用 **Extract Method** ，然后对提炼出来的代码使用 **Pull Up Method**， 将它推入超类内。 
3. 如果两个毫不相关的类出现 **Duplicated Code** ，应该考虑把重复代码提炼到其中一个类或者第三个类。

### 3.2 Long Method(过长函数)

* 每当感觉需要以注释来说明点什么的时候，就把需要说明的东西写进一个独立的函数内，并以其 **用途** (并非实现手法)命名。只要函数名称能解释其用途，应该毫不犹豫的这么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。

### 3.3 Large Class(过大的类)

* 一个类内如果有太多实例变量或者代码，往往可以使用 **Extract Class** 和 **Extract Subclass** 提炼。

### 3.4 Long Parameter List(过长参数列)

* 对于太长的参数列，可以传入一个对象，让函数自己从对象中获取数据。

### 3.5 Divergent Change(发散式变化)

* 我们希望软件更容易被修改，一旦需要修改，我们希望能跳转到一个点，只在该处做修改，如果不能做到，就要注意了。如果某个类经常因为不同的原因在不同的方向上变化， **Divergent Change** 就出现了。针对某一外界变化的所有相应修改都应该只发生在单一类中，而这个类内的所有内容都应该反应此变化。

### 3.6 Shotgun Surgery(霰弹式修改)

* **Shotgun Surgery** 类似 **Divergent Change**。 如果遇到某种变化，都必须在许多不同的类内作出许多小的修改，你面临的坏味道就是 **Shotgun Surgery(霰弹式修改)**。

* **Divergent Change** 是指 “一个类受多种变化的影响”， **Shotgun Change** 则是指一种变化引发多个类相应修改。这两种情况下都应该整理代码，使“外界变化”与“需要修改的类”趋于一一对应。

### 3.7 Feature Envy(依恋情节)

* 一种经典的气味是：函数对某个类的兴趣高过自己所处类的兴趣。

### 3.8 Data Clumps(数据泥团)

* 总是绑在一起出现的数据应该拥有属于他们自己的对象，这样可以减少字段和参数的个数。

### 3.9 Primitive Obsession(基本类型偏执)

### 3.10 Switch Statements(Switch惊悚现身)

* 看到switch语句的时候，多数应该以多态替代，或者把分支的执行拆分成函数。

### 3.11 Parallel Inheritance Hierarchies(平行继承体系)

* 这是 **Shotgun Surgery** 的一种特殊情况。这种情况下每为一个类增加一个子类，也必须为另一个类增加一个子类。这种情况下一般策略是：让一个继承体系的实例引用另一个继承体系的实例。

### 3.12 Lazy Class(冗余类)

### 3.13 Speculative Generality(跨跨其谈未来性)

* 如果以总有一天需要做这事，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。如果函数或类的唯一用户是测试用例，那就飘出了这种坏味道。

### 3.14 Temporary Field(令人迷惑的暂时字段)

* 对象内某个实例变量仅为某种特定情况而设。这时候我们可以把这些变量和相关函数提炼到一个独立类中。

### 3.15 Message Chains(过度耦合的消息链)

* 如果用户向一个对象请求另一个对象，然后再向后者请求另一个对象……这就是消息链。我们可以把使用该对象的代码提炼到一个独立函数中，然后把这个函数推入消息链中。

### 3.16 Middle Man(中间人)

* 某个类接口有一半的函数都委托给其他类，这就是过度运用委托。这时候应该使用 **Remove Middle Man**，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以把它们放入调用端。 如果他们还有其他行为，可以使用 **Replace Delegation with Inheritance** 把它变成实责对象的子类，这样既可以拓展原对象的行为，又不必负担那么多的委托动作。

### 3.17 Inappropriate Intimacy(狎昵关系)

* 如果两个类花费太多时间去探究彼此的private成分，那么我们可以把他们分开或者提炼出共同点，创造一个新类。

### 3.18 Alternative Classes with Different Interfaces(异曲同工类)

* 如果两个函数做一件事但是有不同的签名，应该给他们重新命名，但这往往不够，还需要把某些行为移入类，直到两者的协议一致为止。

### 3.19 Incomplete Library Class(不完美的类库)

### 3.20 Data Class(纯稚的数据类)

### 3.21 Refused Bequest(被拒绝的遗赠)

* 如果子类不想继承超类的部分函数或者数据，按照传统说法，这常常意味着继承体系设计错误。

### 3.22 Comments(过多的注释)

* 过多的注释往往意味着代码设计糟糕，这个常常可以指示我们来寻找坏味道。

## 第4章 构筑测试体系

* 在少量比较容易出错的地方添加单元测试能够得到最高的收益，单元测试不能保证找出所有bug，但是能花合理时间找出大多数bug即可。

## 第5章 重构列表

### 5.1 重构的记录格式

每个重构手法都有如下五个部分：

* 名称。

* 简短概要  简单介绍此一重构手法的适用场景，以及它所做的事情。

* 动机  为你介绍“为什么需要这个重构” 和 “什么情况下不该使用这个重构”。

* 做法  简明扼要地一步一步介绍如何进行此一重构。

* 范例  以一个十分简单的例子说明此重构手法如何运作。

### 5.2 寻找引用点

* 不要盲目地查找-替换，应该检查每一个引用点，确保指向我们要替换的东西。

## 第6章 重新组织函数

### 6.1 Extract Method(提炼函数)

* **概要** ： 有一段代码可以被组织在一起并独立出来，将这段代码放入一个独立函数中，并让该函数名解释该函数的用途。

* **动机** ：1.每个函数粒度都很小的话，那么复用的机会更大。2.如果函数都是细粒度，更容易复写。

* **做法** ：

  1. 创建一个新函数，根据这个函数的意图来对它命名。（以它“做什么”来命名，而不是以它“怎么做”来命名）。

  2. 将提炼出的函数复制到新建的目标函数中。

  3. 仔细检查提炼出的代码，看其中是否引用了“作用域限于源函数”的变量。（包括局部变量和源函数参数）

  4. 检查是否有“仅用于被提炼代码段”的临时变量，如果有，在目标函数中将它们声明为临时变量。

  5. 检查被提炼代码段，看看是否有任何局部变量的值被它改变。如果一个临时变量值被修改了，看看是否可以将被提炼代码段处理为一个查询，并将结果赋值给相关变量。如果很难这样做，或如果被修改的变量不止一个，就不能仅仅将这段代码原封不动的提炼出来。可能需要先使用 **Split Temporary Variable** ，然后再尝试提炼。也可以使用 **Replace Temp with Query** 将临时变量消灭掉。

  6. 将被提炼代码段中需要读取的局部变量，当作参数传给目标函数。

  7. 处理完所有局部变量之后，进行编译。

  8. 在源函数中，将被提炼代码段替换为对目标函数的调用。

  9. 编译，测试。