# 《C#图解教程》

## 第1章 C#和.NET框架

### 1.2 

* 严格的说，.NET 框架由两部分组成：CLR(Common Language Runtime, 公共语言运行库)和FCL(Frame Class Library, 框架类库)，不包括工具。FCL是BCL(Base Class Library, 基类库)的超集，还包括Windows Forms、 ASP.NET LINQ 以及更多命名空间。

## 第2章 C#编程概述

### 2.6

* 格式字符串语法如下:  
    ```c#
    Console.WriteLine(格式字符串（含代替标记），替换值1，替换值2，替换值3，...);
    ```  
  例子如下:  
    ```c#
    Consle.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
    ```

## 第3章 类型、存储和变量

### 3.8

* 对于引用类型的任何对象，它所有的数据成员都存放在堆里，无论它们是值类型还是引用类型。

## 第4章 类：基础

## 第5章 方法

### 5.2

* `var` 关键字不是某种特别类型的符号，只是句法上的速记，表示任何可以从初始化的右边推出的类型。它有一些重要条件：
    1. 只能用于本地变量，不能用于字段
    
    2. 只能在变量声明中包含初始化时使用
    
    3. 一旦编译器推断出类型，它就是固定且不能更改的。

### 5.8 

* 使用应用参数时，必须在方法的声明和调用中都使用 `ref` 修饰符。实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或者null值。引用参数有以下特征:

    1. 不在栈中为形参分配新的内存

    2. 形参的名称相当于实参变量的别名，引用于实参相同的内存位置。

### 5.9

* 输出参数用于从方法体内把数据传出到调用代码，它们非常类似引用参数，有以下要求：

    1. 必须在声明和调用中都使用修饰符。输出参数的修饰符是 `out` 而不是 `ref`。

    2. 实参必须是变量，不能是其他表达式类型。

    3. 在方法内部，输出参数被读取之前必须被赋值。这意味着参数的初始值是无关的，而且没有必要在方法调用之前为实参赋值。

    4. 每个输出参数在方法返回之前必须被赋值。

### 5.10

* 参数数组允许零个或多个实参对应一个特殊的形参，参数数组的重点如下:

    1. 在一个参数列表中只能有一个参数数组

    2. 如果有，它必须是列表中最后一个

    3. 在数据类型前使用 `params` 修饰符。

    4. 在数据类型后放一组空的方括号

* int型参数数组声明语法例子:
    ```c#
    void ListInts(param int[] inVals)
    {}

    //有两个调用方法提供实参

    //一个逗号分隔的该数据类型元素的列表，所有元素必须是方法中声明的类型
    ListInts(10, 20, 30);

    //一个该数据类型的元素的一维数组
    int[] intArray = {1, 2, 3};
    ListInts(intArray);
    ```

### 5.14

* 一个类中可以有一个以上的方法拥有相同的名称，这叫做方法重载。使用相同名称的每个方法必须有一个和其他方法不相同的签名。方法的签名有以下信息组成，它们在方法声明的方法头中：

    1. 方法的名称。

    2. 参数的数目。

    3. 参数的数据类型和顺序。

    4. 参数修饰符。

* 返回类型和形参的名称**不是**签名的一部分。

## 第6章 类进阶

### 6.1

* 类成员声明语句由下列部分组成：核心声明、一组可选的修饰符（modifier）和一组可选的特性（attribute）。用于描述这个结构的语法如下。方括号表示方括号内的成分是可选的。
```
[特性] [修饰符] 核心声明
```  
如果一个声明有多个修饰符，它们可以以任何顺序放在核心声明之前。比如下面语句是语义等价的：
```c#
public static int MaxVal;
static public int MaxVal;
```

### 6.7

* 成员常量(const)和真正的静态变量不同，它没有自己的存储位置，而是在编译时被编译器替换，这种方式类似于C和C++中的#define值。

### 6.8

* 属性和字段不同，属性是一个**函数成员**。它不为数据存储分配内存。它执行代码。属性是制定的一组两个匹配的、称为**访问器的方法**。

    1. `set` 访问器用于为属性赋值。

    2. `get` 访问器用于从属性获取值。

* `set` 访问器总是：

    1. 一个单独的、隐式的值参，名称为value，与属性的类型相同。
   
    2. 一个返回类型void

* `get` 访问器总是:

    1. 没有参数。

    2. 一个数属性类型相同的返回类型。

* 可以通过忽略访问器的声明，以使一个其他的属性访问器不被定义。

### 6.10

* 构造函数也可以声明为 `static`。实例构造函数初始化类的每个新实例，而static构造函数初始化类层次的项目。通常，静态构造函数初始化类的静态字段。不能显示调用静态构造函数，它们被系统自动调用：

    1. 在类的任何实例被创建之前

    2. 在类的任何静态成员被引用之前

### 6.11 对象初始化列表

* 对象初始化列表允许在创建新的对象实例时设置字段和属性的值：

    1. 被初始化的成员在创建对象的代码中必须是可访问的（如public）

    2. 初始化在构造函数完成之后发生。

### 6.14

* 字段可以用 `readonly` 修饰符声明，其作用类似于声明一个字段为 `const` ，一旦值被设定就不能改变。`const` 字段只能在字段的声明语句中初始化，而`readonly` 字段可以在下列任意位置设置它的值:

    1. 字段声明语句，如同const

    2. 类的任何构造函数。如果是static字段，初始化必须在static构造函数中完成。

* `const` 字段的值必须在编译期决定，而 `readonly` 字段的值可以在运行期决定。

### 6.16

* 索引是一组 `get` 和 `set` 访问器，需要注意以下几点：

    1. 索引没有名称，在名称的位置是关键字`this`

    2. 参数列表在**方括号**中间

    3. 参数列表中至少必须声明一个参数
   
```c#
ReturnType this [Type param1, ...]
{
    set
    {
        SetAccessorCode
    }
    get
    {
        GetAccessorCode
    }
}
```

* 索引总是实例成员，因此不能被声明为 `static`

### 6.18

* 类的声明可以被分割成几个分部类的声明：

    1. 每个分部类的声明都含有一些类成员的声明。

    2. 类的分部类声明可以在同一个文件中也可以在不同的文件中。

* 每个局部声明必须被标为 `partial class`

## 第7章 类和继承

### 7.3

* 覆盖基类的成员可以用 `new` 关键字显式覆盖

### 7.4

* 可以使用基类访问表达式访问隐藏的基类成员，基类访问表达式由关键字 `base` 后面跟着一个点和成员的名称组成。

### 7.5

* 使用基类的引用不能 “看到” 派生类对象的其余部分，因为它通过基类的引用 “看” 这个对象。

* 可以使用基类引用调用派生类（derived class）的方法，只需满足下面的条件：

    1. 派生类的方法和基类的方法有相同的签名和返回类型。

    2. 基类的方法使用 `virtual` 标注

    3. 派生类的方法使用 `override` 标注

    4. 覆写和被覆写的方法必须有相同的可访问性，不能被覆写的方法是private等，而覆写方法是public。

    5. 不能覆写static方法或非虚方法

### 7.7

* 类的可访问性有两个级别： `public` 和 `internal` 。标记为 `internal` 的类只能被它自己所在的程序集内的类看到。不声明默认为 `internal`。

### 7.8

* 访问级别的成员声明有5中

    1. `public` ：所有类都可自由访问

    2. `private` :限制最严格的，仅自己可访问

    3. `protected` :仅自己和派生类可以访问

    4. `internal`:对程序集内所有类可见

    5. `protected internal`: `protected` 和 `internal` 的**合集**。

### 7.9

* 抽象成员是设计用来覆写的函数成员，用 `abstract` 修饰，没有实现代码块，被分号替代。

* 不能把 `virtual` 修饰符附加到 `abstract` 修饰符。派生类抽象方法的实现必须使用 `override` 修饰符。

### 7.11

* **密封类** 必须用作独立的类，不能被作为基类,使用 `sealed` 修饰符标注。

### 7.12

* 静态类所有的成员都是静态的。用于分组不受实例影响的数据和函数，比如创建一个包含一组数学方法的数学库。所有的成员必须是静态的，不能继承静态类，它们是密封的。

### 7.13

* 通过 `this` 关键字，可以把一个方法从类的正规方法变成另一个类的拓展方法,需求如下：

    1. 拓展方法必须被声明为 `static`。

    2. 拓展方法声明所在的类也必须被声明为 `static`

    3. 拓展方法必须包含关键字 `this` 作为它的第一个参数类型，并在后面跟着它所拓展的类的名称。  
例:
```c#
// 必须是一个静态类
static class ExtendMyData
{
    // 必须是公有和静态的
    public static double Average(this MyData md)
    {
        ...
    }
}

//调用
md.Average()
```

### 7.14

* **外部方法** 是在声明中没有实现的方法，其实现常常是用c#之外的语言编写的。 外部方法使用 `extern` 修饰符标记，而且在类的声明中没有实现，实现被分号取代。例:
  ```c#
  public static extern int GetCurrentDirectory(int size, StringBuilder buf); 
  ```

* 声明和实现的链接依赖实现，但是常常由 `DllImport` 特性完成。

## 第8章 表达式和运算符

### 8.2

* **字面量** 是原代码中书写的数字或字符串，表示一个明确类型的、固定的值。

### 8.14

* 声明隐式转换的语法如下,其中 `public` 和 `static` 修饰符是所有用户定义转换必需的:
    ```c#
    public static implicit operator TargetType(SourceType Identifier)
    {
        ...
        return ObjectTargetType;
    }
    ```

* 显式转换的语法跟隐式相同，除了 `explicit` 替换掉 `implicit` 。
  ```c#
  public static implicit operator int (LimitedInt li)
  {
      return li.TheValue;
  }
  ```

### 8.15

* 运算符重载允许定义c#运算符应该如何操作自定义类型的操作数:
  ```c#
  public static LimitedInt operator -(LimitedInt x); // 一元运算符的重载带一个单独的class类型或struct类型的参数
  public static LimitedInt operator +(LimitedInt x, double y); //二元运算符的重载带两个参数，其中一个至少必须是class或struct类型
  ```

* 运算符重载方法必须被声明为带 `static` 和 `public` 两个修饰符。

* 可以重载的运算符只有下列这些:
  ```
  一元运算符：+、-、!、-、++、--、true、false
  二元运算符：+、-、*、/、&、|、^、<<、>>、==、!=、>、<、>=、<=
  ```

### 8.16

* `typeof` 运算符返回作为它的参数的任何类型的 `System.Type` 对象。

## 第9章 语句

### 9.13

* `using` 语句帮助减少额外的运行时错误带来的潜在问题。
  ```c#
  using (ResourceType Identifier = Expression) Statement //Statement是使用资源的代码，using语句隐式产生处置该资源的代码。
  ```

## 第10章 命名空间和程序集

### 10.3

* `using` 指令词必须放在源文件的顶端，在任何类型声明之前。它们应用于当前源文件中的所有命名空间。

* `using` 别名指令允许起一个别名给命名空间或者命名空间内的一个类型
  ```c#
  using Syst = System;
  using SC = System.Console;
  ```

### 10.4

* 程序集包括:
  
  1. 清单
  
  2. 类型元数据
  
  3. CIL代码(公共中间语言代码)
  
  4. 资源

### 10.6

* 强命名程序集有一个唯一的数字签名依附于它。强命名程序集默认只能访问其他强命名程序集。

### 10.8

* 有时候我们会想把DLL放在一个中心位置，这样一个单独的拷贝就可以被系统中其他程序共享。.NET有这样的贮藏库，称为 **全局程序集缓存(GAC)** 。放进GAC的程序集称为 **共享程序集** 。GAC的位置在 Assembly 子目录下，在 Windows 系统目录中。

## 第11章 异常

### 11.2

* 异常用法
  ```c#
  try
  {
      ...
  }
  catch [(ExceptionType [InstID])]
  {
      ...
  }
  finally
  {
      ...
  }
  ```

### 11.3

* 当一个异常发生时，CLR创建该类型的异常对象，寻找合适catch语句处理它。所有异常根本上派生自System.Exception.

### 11.5

* 如果程序的控制流进入了一个带 `finally` 块的 `try` 语句，那么 `finally` 始终会执行，即使 `try` 中含有return语句，也会在返回之前执行 `finally` 中的语句。

### 11.9

* 如果在 `catch` 块内部 `throw` 语句不带异常对象使用，会重新抛出当前异常。

## 第12章 结构

### 12.1

* 结构跟类最重要的区别是:

    1. 类是引用类型而结构是值类型

    2. 结构是隐式密封的，这意味着它们不能被派生

### 12.2

* 跟所有的值类型一样，结构类型变量含有自己的数据，因此结构类型的变量 **不能为`null`** ,两个结构变量不能引用同一个对象。

### 12.3

* 把一个结构赋值给另一个结构，就是从一个结构中把值赋值到另一个结构。这和赋值变量不同，赋值类变量时只有引用被赋值。

### 12.4

* 结构允许有实例构造函数和静态构造函数，但不允许有析构函数。

* 要调用一个构造函数，包括隐式无参数构造函数，要使用 new 运算符，即使不从堆中分配内存也要使用 new 运算符。也可以不用 new 运算符创造结构的实例，但是这样子做有一些限制：

    1. 不能使用任何数据成员的值，直到显式设置它

    2. 不能调用任何函数成员，直到所有数据成员已被赋值。

* 在结构中初始化字段是不允许的

### 12.6

* 结构是隐式密封的，因此，不能从它们派生其他结构。结构可以使用的两个继承相关的关键字是 `new` 和 `override` ，当创建一个和基类 `System.ValueType` 的成员有相同名称的成员时使用它们。

### 12.9

* 分配结构比创建类的实例需要更少的消耗，所以使用结构代替类有时可以提高性能，但要最后注意到装箱和取消装箱的高代价。

* 预定义为简单类型(int、short、long，等等)，尽管在.NET和C#中被视为原始类型，它们在.NET中都被实现为结构。

* 结构，就像类，可以实现接口。

## 第13章 枚举

* 可以通过把冒号和类型名放在枚举名之后以使用int以外的整数类型，类型可以是除了char以外的所有整数类型,所有成员常亮都属于枚举的底层类型。
  ```c#
  enum TrafficLight : uLong //底层类型
  {
      ...
  }
  ```

### 13.2

* Flags特性可以提供方便的特征:

    1. 通知该枚举的成员将要被结合成位标志，而不只是作为分开的值使用。这使得浏览器更合适的解释该枚举类型的变量。

    2. 它允许一个枚举的ToString方法，以对位标志的值提供更合适的格式化。

## 第14章 数组

### 14.1

* 有两种类型的多维度数组: **矩形数组** 和 **交错数组**。

* **矩形数组**
  
  1. 某个维度的所有子数组有相同长度的多维数组。
   
  2. 不管有多少个维度，都只用一个方括号。

* **交错数组**
  
  1. 每一个子数组都是独立数组的多维数组
  
  2. 可以有不同长度的子数组
   
  3. 为数组的每一个维度使用一对方括号

### 14.4

* 声明一维数组或矩形数组，可以在类型和变量名称之间使用一对方括号。方括号内的逗号就是秩说明符，它们指定了数组的维度数。秩就是 **逗号数量加1** 。数组声明后，维度数就是固定的了，然而，维度长度直到数组实例化才会被确定。
  ```c#
  long[ ] secondArray; //一维数组  
  int[,,] firatArray;  // 三维数组
  ```

* 要实例化一维数组或矩形数组，可以使用数组创建表达式。数组创建表达式由 `new` 运算符构成，后面是基类名称和一对方括号。方括号中以逗号分隔每一个维度的长度。
  ```c#
  int[,,] arr3 = new int[3, 6, 2];
  ```

### 14.7

* 对于一维数组，可以通过在数组实例化的数组创建表达式之后包括初始化列表来设置显式初始值。数组维度是可选的，因为编译器可以通过初始化值的个数来推断长度。
  ```c#
  int[] intArr = new int[] {10,20,30,40};
  ```
  也可以显式初始化矩形数组
  ```c#
  int [,] intArray2 = new int[,] {{10, 1}, {2, 10}, {11, 9}};
  ```
  甚至可以省略创建表达式
  ```c#
  int [,] intArray2 = {{10, 1}, {2, 10}, {11, 9}};
  ```
### 14.8

* 交错数组的声明语法要求每一个维度都有一对独立的方括号，数组变量声明中的方括号数决定了数组的秩。
  ```c#
  int[][] jagArr = new int[3][]; //声明并创建顶层数组
    ...                          //声明并创建子数组
  ```

* 和其他类型的数组不同，交错数组的完全初始化不能在一个步骤中完成，每一个数组必须独立创建。
  ```c#
  int[][] Arr = new int[3][];
  Arr[0] = new int[] {10, 20, 30};
  Arr[1] = new int[] {40, 50, 60, 70};
  Arr[2] = new int[] {80, 90, 100, 110, 120};
  ```

* 由于交错数组中的子数组本身就是数组，因此交错数组中可能有矩形数组。
  ```c#
  int[][,] Arr;
  Arr = new int[3][,];
  ```

## 第15章 委托

### 15.1

* **委托(delegate)** 包含具有相同签名和返回值类型的有序方法列表，与C++中的指针不同的是，它是面向对象且类型安全的。
  
  1. 方法的列表被称为 **调用列表(invocation list)**
   
  2. 当委托被调用时，它调用列表中的每一个方法

* 由委托保存的方法可以来自任何类或结构，只要它们同时匹配委托的如下两点：
  
  1. 返回值
   
  2. 签名（包括 `out` 和 `ref` 修饰符)

### 15.3

* 有两种方式创建委托对象:
  1. 使用带 `new` 运算符的对象创建表达式:
  ```c#
  MyDel delVar; //声明委托变量
  delVar = new MyDel(myInstObj.MyM1);//创建委托并保存引用
  ```
  2. 使用快捷语法
  ```c#
  delVar = myInstObj.MyM1;
  ```

### 15.7

* 使用 `-=` 从委托移除方法的时候，其实是创建了一个新的委托，它会从列表的最后开始搜索，并且移除第一个匹配的实例，试图删除委托中不存在的方法没有效果，试图调用空委托会抛出异常，如果调用列表为空，则委托为 `null` 。

### 15.10

* 如果委托有返回值并且委托列表有一个以上的方法，调用列表中最后一个方法返回的值就是委托调用返回的值，其他所有方法的返回值都会被忽略。

* 匿名方法表达式的语法包含以下部分:
  1. delegate类型关键字
  2. 参数列表，如果语句没有任何参数可以省略
  3. 语句块，它包含了匿名方法的代码
   ```c#
   delegate (Parameters) {ImplementationCode}
   ```

* 可以通过使圆括号为空或者省略圆括号来简化匿名方法的参数列表，但是仅在下面两项都为真的情况下才可以这么做:
  1. 委托的参数列表不包含任何 `out` 参数
  2. 匿名方法不适用任何参数

* 如果委托声明的参数列表包含了 `param` 关键字，那么关键字会被匿名方法的参数列表忽略。

## 第16章 事件

### 16.2

* 委托的源代码组件有5个部分
  1. 委托类型声明：事件和事件处理程序必须有共同的签名和返回类型，它们通过委托类型声明进行描述。
  2. 事件处理程序声明：这些在订阅者类的方法（事件处理程序）中的描述会在事件触发时被执行。它们不需要有独立的方法，它们可以是匿名函数或者lambda表达式。
  3. 事件声明：这个事件发布者类中的声明保存并调用事件处理程序。
  4. 事件注册：这段代码把事件连接到事件处理程序。
  5. 触发事件的代码：发布者类中的这段代码调用事件导致它调用事件处理程序。

* 事件不是类型，是成员，会隐式初始化为null。

* 最好使用.NET BCL使用的并被指为事件使用标准的预定义委托类型 EventHandler。

### 16.6

* 事件使用的标准模式的根本就是System的命名空间声明的 `EventHandler` 委托类型。声明如下所示:
  1. 第一个参数用来保存触发事件的对象的引用。由于是object类型，可以匹配任何类型的实例。
  2. 第二个参数用来保存有关状态对于应用程序来说是否合适的状态信息
  3. 返回类型是 `void`
    ```c#
    public delegate void EventHandler(object sender, EventArg e);
    ```

* `EventArgs` 被设计为不能传递任何数据。它用于不需要传递数据的事件处理程序。通常会被忽略。如果你希望传递数据，必须声明一个从 `EventArgs` 继承的类，使用合适的字段来保存需要传递的数据。

* 使用自定义委托的方式有两种：
  1. 第一种方式是使用非泛型委托
   ```c#
   public delegate void MyTCEventHandler(object sender, MyTCEventArgs e);
   ```

  2. 使用 `EventHandler` 泛型委托的方式。
   ```c#
   public event EventHandler<MyTCEventArgs> Elapsed;
   ```

### 16.8

* 可以通过修改 `add` 和 `remove` 运算符的行为来改变 `+=` 和 `-=` 的行为。

## 第17章 接口

### 17.1

* 要使用数组的 `Sort` 函数排序自定义类，需要为自定义类继承 `IComparable` 接口，并且实现 `CompareTo` 方法。
  
* 接口声明不包含数据成员，只能包含如下类型的静态数据成员的声明:
  1. 方法
  2. 属性
  3. 事件
  4. 索引

* 这些函数成员的声明不能包含任何实现代码，而在每一个成员声明的主体后必须使用分号。

* 按照惯例，接口必须从大写的I开始

* 接口声明可以有任何的访问修饰符public、protected、internal 或 private等。然而，接口是隐式public的，不允许任何访问修饰符，包括public。

### 17.3

* 要实现接口，必须在基类列表中包括接口名称，为每一个接口的成员提供实现。如果从基类中继承并实现接口，基类名称必须放在任何接口之前。

### 17.4

* 接口是一个引用类型，可以通过把类对象引用强制转化成接口类型来获取指向接口的引用。

### 17.10

* 接口可以采用显式接口实现，这种情况下可以没有类级别的实现:
  ```c#
  class MyClass:IIfc1, IIfc2
  {
      void IIfc1.PrintOut(string s)
      {
          ...
      }
      void IIfc2.PrintOut(string s)
      {
          ...
      }
  }
  ```

* 显式接口实现只可以通过指向接口的引用来访问，其他的类成员不可以直接访问它们。

## 第18章 转换

### 18.2

* 从更小的无符号类型转化为更大的无符号类型时，目标中多出来的最高位都用0填充，这叫零扩展。

* 对于有符号的转换而言，额外的高位用原表达式的符号位进行拓展，这叫做符号拓展。

### 18.5

* 可以使用 `checked` 和 `unchecked` 来检查或者忽略类型转换时结果的溢出。

* 将一个基本类型引用显式转换为它继承的类的引用，编译时不会报错，但是运行时可能会抛出 `InvalidCastException`, 如果尝试访问继承类独有的成员。

### 18.10

* 可以使用 `is` 运算符来检查一个转换是否会成功完成，只能用于引用转换、装箱转换和拆箱转换
  ```c#
  Expr is TargetType
  ```

### 18.11

* `as` 运算符和强制转换运算符类似，只是它不抛出异常，如果转换失败，它把目标引用设置为null而不是抛出异常。只用用于引用转换和装箱转换。
  ```c#
  Expr as TargetType
  ```

## 第19章 泛型

### 19.2

* 类型不是对象，而是对象的模板。同样的，泛型不是类型，是类型的模板。

### 19.7

* 用让泛型更加有用，需要提供额外信息让编译器知道参数可接受哪些类型，这些额外的信息叫做约束。约束用 `where` 字句列出:
  ```c#
  where TypeParam : constraint, constraint
  ```

* `where` 子句要点如下:
  1. 它们在类型参数列表的关闭尖括号之后列出
  2. 不适用使用括号或其他符号分隔
  3. 可以以任何次序出现
  4. `where` 是上下文关键词，所以可以在其他上下文中使用

* 例如以下泛型有三个类型参数。T1是未绑定的，只有Customer类型或从Customer类型继承类型的类才能用作T2的实参，只有实现IComparable接口的类才能用于类型实参。
  ```c#
  class MyClass<T1, T2, T3>
                where T2:Customer
                where T3:IComparable
  {
      ...
  }
  ```

* 公有5种类型的约束:  
  | 约束类型 | 描述 |
  | -- | -- |
  | 类名 | 只有这个类型的类或从它继承的类才能用作实参 |
  | class | 任何引用类型，包括类、数组、委托和接口都可以用作实参
  | struct | 任何值类型都可以被用作类型实参 |
  | InterfaceName | 只有这个接口或实现这个接口的类型才能用作实参|
  | new() | 任何带有无参公共构造函数的类型都可以用作实参，这叫做构造函数约束 |

* `where` 子句可以以任意次数列出，然而 `where` 子句中的约束必须有特定的顺序。
  1. 最多只能有一个主约束，如果有必须放在第一位
  2. 可以有任意多的 `InterfaceName` 约束。
  3. 如果存在构造函数约束，则必须放在最后

### 19.10

* 要声明泛型委托，在委托名称后、委托参数列表之前的尖括号中放类型参数列表。
  ```c#
  delegate R MyDelegate<T, R>(T value);
  var myDel = MyDelegate<string, int>(func);
  ```

### 19.11

* 要声明泛型方法，需要:
  1. 在方法名称和方法参数列表之前放类型参数列表。
  2. 在方法参数列表后放可选的约束子句。
   ```c#
   public void PrintData<S, T> (S p) where S:Person
   {
       ...
   }
   ```
### 19.12

* 拓展方法可以跟泛型类结合使用，允许将类中的静态方法关联到不同的泛型类型上。

## 第20章 枚举数和迭代器

### 20.1

* 在.NET中获取一个对象枚举数的标准方法是调用一个对象的 `GetEnumerator` 方法。 实现 `GetEnumerator` 方法的类型叫做可枚举类型。

* 枚举数一共有三种:
  1. `IEnumerator/IEnumerable`接口——叫做非泛型接口形式。
  2. `IEnumerator<T>/IEnumerable<T>`接口——叫做泛型接口形式。
  3. 不使用接口形式

* `IEnumerator` 包含三个函数成员:
  1. `Current` 返回序列中当前位置项的属性
  2. `MoveNext` 是把枚举数位置前进到集合中下一项的方法。也返回布尔值，指示新的位置是有效位置或已经超过了序列的尾部。
  3. `Reset` 方法把位置重置为原始状态。

* `IEnumerable` 接口只有一个成员——`GetEnumerator`，返回对象的枚举数。

### 20.4

* 使用 `IEnumerator` 和 `IEnumerable` 有几个缺点:
  1. `current` 返回的是 `object` 类型的，对于值类型而言，装箱拆箱会带来严重的性能问题。
  2. 非泛型方法失去了类型安全，值被作为对象来枚举，消除了编译时的类型检测。

* 可以通过对枚举数和可枚举类的声明做改变来解决这个问题
  1. 对于枚举数类： 
    1. 不要继承自 `IEnumerator`
    2. 像以前一样实现 `MoveNext`
    3. 像以前一样实现 `Current`，把返回类型设置为何枚举的一样
    4. 不需要实现 `Reset`
  2. 对于可枚举类： 
    1. 不要继承自 `IEnumerable`
    2. 像以前一样实现 `GetEnumerator`，设置返回值为枚举数类。

* 这种做法一个可能存在的问题是其他程序集使用接口方法实现枚举，要解决这个问题，可以在同一个类中实现两种形式，在类级别创建 `Current` 等实现，也为它们创建显式接口实现。

### 20.6

* `IEnumerator<T>` 接口使用泛型来返回实际的类型，而不是object类型的对象，它从另外两个接口继承——非泛型的 `IEnumerable` 接口和 `IDisposable` 接口。 `IDisposable` 接口只有一个叫做 `Dispose` 的类型为void的无参方法，用于释放由类占据的非托管资源。

### 20.8

* `yield return` 语句执行了序列中返回的下一项。
* `yield break` 语句指定在序列中没有更多项。

## 第21章 介绍LINQ

### 21.1

* `LINQ` 是集成到C#和Visual Basic.NET 这些语言中用于提供查询数据能力的一个新特性。以下是 `LINQ` 重要高级特性：
  1. LINQ(发音为link)代表语言集成查询（Language Integrated Query）
  2. LINQ是.NET框架的的拓展，它允许我们以数据库查询的方式查询数据集合。
  3. C# 3.0 包含整合LINQ到语言中的一些拓展，允许我们从数据库、程序对象集合以及XML文档中查询数据。

### 21.2

* 匿名类型创建代码示例如下：
  ```c#
  static void Main()
  {
      var student = new {LName="Jones", FName="Mary", Age=19, Major="History"};
      Console.WriteLine("{0} {1}, Age {2}, Major:{3}", student.FName, student.LName, student.Age, student.Major);
  }
  ```
* 匿名类型需要注意
  1. 匿名类型只能配置局部变量使用，不能用于类成员
  2. 由于匿名类型没有名字，必须使用var作为变量类型

* 有两种形式的语法可以供我们在写LINQ的使用使用
  1. **查询语法** 是声明形式的，看上去跟SQL语句很相似，查询语句使用查询表达式形式书写。
  2. **方法语法** 是命令形式的，它使用的是标准的方法调用。方法是一组叫做标准查询运算符的方法。

* 两种方法使用示例
  ```c#
  static void Main()
  {
      int[] numbers = {2, 5, 28, 31};
      var numsQuery = from n in numbers // 查询语法
                      where n < 20
                      select n;
      var numsMethod = numbers.Where(x => x < 20); // 方法语法
      int numsCount = (from n in numbers // 两种形式的结合
                       where n < 20
                       select n).Count();
  }
  ```

### 21.4

* `LINQ` 查询可以返回两种类型的结果：
  1. 一个枚举，列出了满足查询参数的项列表，如果查询表达式返回枚举，查询一直到处理枚举时才执行，如果枚举被处理多次，查询就会被**执行多次**。
  2. 一个叫做标量的单一值，它是满足查询条件的结果的某种摘要形式。如果查询返回标量，查询会立即执行并且把结果放到查询变量中。

### 21.5

* 联结语法如下:
  ```
  join Identifier in Collection2 on Field1 equals Fields2
  ```
  示例
  ```c#
  var query = from s in students 
              join c in studentsInCourses on s.StID equals C.StID;
  ```

* `let` 语句接受一个表达式的运算并且把它赋值给一个需要在其他运算中使用的标志符。
  ```c#
  let Identifier = Expression
  ```
* `orderby` 子句接受一个表达式并根据表达式依次返回结果项。默认排序是升序，可以使用`ascending` 和 `descending` 关键词显式设置元素的排序为升序或降序。可以有任意多个子句，必须用逗号分离。

* `group` 子句把 `select` 的对象根据一些标准分组，作为分组依据的项叫键(key)。`gourp` 子句不从原始的数据源中返回可枚举项的可枚举类型，而是返回可以枚举已经形成的项的分组的可枚举类型。示例如下:
  ```c#
  stctic void Main()
  {
      var students = new []
      {
          new {LName"Jones", Fame="Mary", Age=19, Major="History"},
          new {LName"Jones", Fame="Mary", Age=19, Major="History"},
          new {LName"Jones", Fame="Mary", Age=19, Major="History"}
      };

      var query = from student in students,
                  group student by student.Major;

      foreach(var s in query) // 枚举分组
      {
          Console.WriteLine("{0}", s.Key);

          foreach(var t in s)
          {
              Console.WriteLine("{0} {1}" , t.LName, t.FName);
          }
      }
  }
  ```

