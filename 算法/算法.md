#算法
##动态规划
###背包问题
* f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
`f[i][v]=max{ f[i-1][v], f[i-1][v-w[i]]+v[i] }`。
可以压缩空间，`f[v]=max{f[v],f[v-w[i]]+v[i]}`

* 优化
以上方法的时间和空间复杂度均为O(N\*V），其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V）。
先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？
f[i][v]是由f[i-1][v]和f [i-1][v-w[i]]两个子问题递推而来，能否保证在推f[v]时（也即在第i次主循环中推f[v]时）能够得到f[v]和f[v -w[i]]的值呢？事实上，这要求在 ** 每次主循环中我们以v=V..0的顺序推f[v] ** ，这样才能保证推f[v]时f[v-w[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：
```
for i=1..N
for v=V..0
f[v]=max{f[v],f[v-w[i]]+v[i]};
```
其中的f[v]=max{f[v],f[v-w[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]}，因为的
f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

###应用动态规划问题方法步骤：
1. 刻画一个最优解的结构特征。
2. 递归地定义最优解的值。
3. 计算最优解的值，通常采用自底向上的方法。
4. 利用计算出的信息构造一个最优解。

##图
* 对于图G=(V,E),可以用两种表示方法，一种是将图作为**邻接链表的组合**，另一种将图作为**邻接矩阵**来看待。邻接链表在表示**稀疏图**（边的条数|E|远远小于|V²|的图）成为通常的选择，但是**稠密图**（|E|接近于|V²|）的情况下，倾向于使用邻接矩阵。
* **邻接链表**由包含|V|条链表的数组构成，每个节点有一条链表，对于u∈V，邻接链表包含所有与节点u之间有边相邻的节点v，空间存储需求为Θ（V+E）。缺陷是无法快速判断（u，v）是否是图中的一条边。
* **邻接矩阵**使用|V|×|V|的矩阵
