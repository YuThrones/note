#数据结构
##复杂度符号
* o(g(n)) 严格小于
* O(g(n)) 小于或者等于
* Θ(g(n)) 等于
* Ω(g(n)) 大于
##STL底层数据结构：
1. vector      底层数据结构为数组 ，支持快速随机访问

2. list            底层数据结构为双向链表，支持快速增删

3. deque       底层数据结构为一个中央控制器和多个缓冲区，详细见STL源码剖析P146，支持首尾（中间不能）快速增删，也支持随机访问
deque是一个双端队列(double-ended queue)，也是在堆中保存内容的.它的保存形式如下:
[堆1] --> [堆2] -->[堆3] --> ...
每个堆保存好几个元素,然后堆和堆之间有指针指向,看起来像是list和vector的结合品.

4. stack        底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时

5. queue     底层一般用list或deque实现，封闭头部即可，不用vector的原因应该是容量大小有限制，扩容耗时
（stack和queue其实是适配器,而不叫容器，因为是对容器的再封装）

6. priority_queue     的底层数据结构一般为vector为底层容器，堆heap为处理规则来管理底层容器实现

7. set                   底层数据结构为红黑树，有序，不重复

8. multiset         底层数据结构为红黑树，有序，可重复 

9. map                底层数据结构为红黑树，有序，不重复

10. multimap    底层数据结构为红黑树，有序，可重复

11. hash_set     底层数据结构为hash表，无序，不重复

12. hash_multiset 底层数据结构为hash表，无序，可重复 

13. hash_map    底层数据结构为hash表，无序，不重复

14. hash_multimap 底层数据结构为hash表，无序，可重复 

##stack
* 有push，pop，top，empty等方法
* STL中默认的实现是一个**双向队列**，可以使用基于向量或者表的实现，无论哪种实现，都会保证在常量时间内高效执行
* 添加**析构函数**的目的是防止数据结构在超出管理范围时存在垃圾没有回收，如下例：
```
for(int i = 0; i < 1000000; ++i) {
    Stack small;
	small.push(some_data);
}
```

##树
* 完全二叉树：
  只有最下面的两层结点度能够小于2，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树
  一棵二叉树至多只有最下面的一层上的结点的度数可以小于2，并且最下层上的结点都集中在该层最左边的若干位置上，则此二叉树成为完全二叉树。
![](http://f.hiphotos.baidu.com/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=7ee311d70923dd54357eaf3ab060d8bb/b151f8198618367a6f44126e2e738bd4b21ce5b0.jpg)

* 平衡二叉树：
  它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。构造与调整方法 平衡二叉树的常用算法有红黑树、AVL、Treap等。

* 二叉排序树
  二叉排序树（Binary Sort Tree）又称二叉查找树（Binary Search Tree），亦称二叉搜索树。
  二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
  1. 若左子树不空，则左子树上所有结点的值均小于它的根结点的值；
  2. 若右子树不空，则右子树上所有结点的值均大于它的根结点的值；
  3. 左、右子树也分别为二叉排序树；
  4. 没有键值相等的结点。

* 红黑树（Red Black Tree）
  红黑树是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组，它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O(log n)时间内做查找，插入和删除，这里的n 是树中元素的数目。
  1. 节点是红色或黑色。
  2. 根节点是黑色。
  3. 每个叶节点（NIL节点，空节点）是黑色的。
  4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
  5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

* 树的左旋和右旋：
  1. 左旋  
  ![](http://hi.csdn.net/attachment/201012/29/8394323_1293614183gD0H.jpg)
  2. 右旋  
  ![](http://hi.csdn.net/attachment/201012/29/8394323_1293614183DSC3.jpg)  

##queue
* 有empty,push,pop,front,back,size等方法
* queue实现方法有循环数组，链表
* 保存在数组里的表称为顺序表

##递归
* 包括两个部分：
  1. 不需要用递归处理的最小的、基本的问题
  2. 将特定问题简化为一个或多个更小的问题的通用办法，由此前进，最终将问题一直简化成基本问题
* 尾部递归：
  在函数的最后一个动作调用自己时，不必保存局部变量，因为马上就会被丢弃。尾部递归是可以消除的。

##list（表）
* 方法有：（**STL vector**）
  1. construct：构造表，使它为空
  2. empty
  3. full
  4. size
  5. clear
  6. insert：在指定位置插入一个元素
  7. remove：删除指定位置元素
  8. retrieve：检索指定位置元素
  9. replace
  10. traverse：	遍历此表，对表中的每个元素执行给定的操作

##二叉树
* 定义：一棵二叉树或者是空的，或者是由一个成为根(root)的节点和根的成为左子树跟右子树的两颗二叉树组成。
* AVL树：一种二叉查找树，性能接近于理想的、完全平衡的二叉查找树。
  它的根的左子树和右子树高度差最多为1，每个节点联系着一个平衡因子，可以为左-高（/)、等-高(-)、右-高(\)。

