# 《C#图解教程》

## 第1章 C#和.NET框架

### 1.2 

* 严格的说，.NET 框架由两部分组成：CLR(Common Language Runtime, 公共语言运行库)和FCL(Frame Class Library, 框架类库)，不包括工具。FCL是BCL(Base Class Library, 基类库)的超集，还包括Windows Forms、 ASP.NET LINQ 以及更多命名空间。

## 第2章 C#编程概述

### 2.6

* 格式字符串语法如下:  
    ```c#
    Console.WriteLine(格式字符串（含代替标记），替换值1，替换值2，替换值3，...);
    ```  
  例子如下:  
    ```c#
    Consle.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
    ```

## 第3章 类型、存储和变量

### 3.8

* 对于引用类型的任何对象，它所有的数据成员都存放在堆里，无论它们是值类型还是引用类型。

## 第4章 类：基础

## 第5章 方法

### 5.2

* `var` 关键字不是某种特别类型的符号，只是句法上的速记，表示任何可以从初始化的右边推出的类型。它有一些重要条件：
    1. 只能用于本地变量，不能用于字段
    
    2. 只能在变量声明中包含初始化时使用
    
    3. 一旦编译器推断出类型，它就是固定且不能更改的。

### 5.8 

* 使用应用参数时，必须在方法的声明和调用中都使用 `ref` 修饰符。实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或者null值。引用参数有以下特征:

    1. 不在栈中为形参分配新的内存

    2. 形参的名称相当于实参变量的别名，引用于实参相同的内存位置。

### 5.9

* 输出参数用于从方法体内把数据传出到调用代码，它们非常类似引用参数，有以下要求：

    1. 必须在声明和调用中都使用修饰符。输出参数的修饰符是 `out` 而不是 `ref`。

    2. 实参必须是变量，不能是其他表达式类型。

    3. 在方法内部，输出参数被读取之前必须被赋值。这意味着参数的初始值是无关的，而且没有必要在方法调用之前为实参赋值。

    4. 每个输出参数在方法返回之前必须被赋值。

### 5.10

* 参数数组允许零个或多个实参对应一个特殊的形参，参数数组的重点如下:

    1. 在一个参数列表中只能有一个参数数组

    2. 如果有，它必须是列表中最后一个

    3. 在数据类型前使用 `params` 修饰符。

    4. 在数据类型后放一组空的方括号

* int型参数数组声明语法例子:
    ```c#
    void ListInts(param int[] inVals)
    {}

    //有两个调用方法提供实参

    //一个逗号分隔的该数据类型元素的列表，所有元素必须是方法中声明的类型
    ListInts(10, 20, 30);

    //一个该数据类型的元素的一维数组
    int[] intArray = {1, 2, 3};
    ListInts(intArray);
    ```

### 5.14

* 一个类中可以有一个以上的方法拥有相同的名称，这叫做方法重载。使用相同名称的每个方法必须有一个和其他方法不相同的签名。方法的签名有以下信息组成，它们在方法声明的方法头中：

    1. 方法的名称。

    2. 参数的数目。

    3. 参数的数据类型和顺序。

    4. 参数修饰符。

* 返回类型和形参的名称**不是**签名的一部分。

## 第6章 类进阶

### 6.1

* 类成员声明语句由下列部分组成：核心声明、一组可选的修饰符（modifier）和一组可选的特性（attribute）。用于描述这个结构的语法如下。方括号表示方括号内的成分是可选的。
```
[特性] [修饰符] 核心声明
```  
如果一个声明有多个修饰符，它们可以以任何顺序放在核心声明之前。比如下面语句是语义等价的：
```c#
public static int MaxVal;
static public int MaxVal;
```

### 6.7

* 成员常量(const)和真正的静态变量不同，它没有自己的存储位置，而是在编译时被编译器替换，这种方式类似于C和C++中的#define值。

### 6.8

* 属性和字段不同，属性是一个**函数成员**。它不为数据存储分配内存。它执行代码。属性是制定的一组两个匹配的、称为**访问器的方法**。

    1. `set` 访问器用于为属性赋值。

    2. `get` 访问器用于从属性获取值。

* `set` 访问器总是：

    1. 一个单独的、隐式的值参，名称为value，与属性的类型相同。
   
    2. 一个返回类型void

* `get` 访问器总是:

    1. 没有参数。

    2. 一个数属性类型相同的返回类型。

* 可以通过忽略访问器的声明，以使一个其他的属性访问器不被定义。

### 6.10

* 构造函数也可以声明为 `static`。实例构造函数初始化类的每个新实例，而static构造函数初始化类层次的项目。通常，静态构造函数初始化类的静态字段。不能显示调用静态构造函数，它们被系统自动调用：

    1. 在类的任何实例被创建之前

    2. 在类的任何静态成员被引用之前

### 6.11 对象初始化列表

* 对象初始化列表允许在创建新的对象实例时设置字段和属性的值：

    1. 被初始化的成员在创建对象的代码中必须是可访问的（如public）

    2. 初始化在构造函数完成之后发生。

### 6.14

* 字段可以用 `readonly` 修饰符声明，其作用类似于声明一个字段为 `const` ，一旦值被设定就不能改变。`const` 字段只能在字段的声明语句中初始化，而`readonly` 字段可以在下列任意位置设置它的值:

    1. 字段声明语句，如同const

    2. 类的任何构造函数。如果是static字段，初始化必须在static构造函数中完成。

* `const` 字段的值必须在编译期决定，而 `readonly` 字段的值可以在运行期决定。

### 6.16

* 索引是一组 `get` 和 `set` 访问器，需要注意以下几点：

    1. 索引没有名称，在名称的位置是关键字`this`

    2. 参数列表在**方括号**中间

    3. 参数列表中至少必须声明一个参数
   
```c#
ReturnType this [Type param1, ...]
{
    set
    {
        SetAccessorCode
    }
    get
    {
        GetAccessorCode
    }
}
```

* 索引总是实例成员，因此不能被声明为 `static`

### 6.18

* 类的声明可以被分割成几个分部类的声明：

    1. 每个分部类的声明都含有一些类成员的声明。

    2. 类的分部类声明可以在同一个文件中也可以在不同的文件中。

* 每个局部声明必须被标为 `partial class`

## 第7章 类和继承

### 7.3

* 覆盖基类的成员可以用 `new` 关键字显式覆盖

### 7.4

* 可以使用基类访问表达式访问隐藏的基类成员，基类访问表达式由关键字 `base` 后面跟着一个点和成员的名称组成。

### 7.5

* 使用基类的引用不能 “看到” 派生类对象的其余部分，因为它通过基类的引用 “看” 这个对象。

* 可以使用基类引用调用派生类（derived class）的方法，只需满足下面的条件：

    1. 派生类的方法和基类的方法有相同的签名和返回类型。

    2. 基类的方法使用 `virtual` 标注

    3. 派生类的方法使用 `override` 标注

    4. 覆写和被覆写的方法必须有相同的可访问性，不能被覆写的方法是private等，而覆写方法是public。

    5. 不能覆写static方法或非虚方法

### 7.7

* 类的可访问性有两个级别： `public` 和 `internal` 。标记为 `internal` 的类只能被它自己所在的程序集内的类看到。不声明默认为 `internal`。

### 7.8

* 访问级别的成员声明有5中

    1. `public` ：所有类都可自由访问

    2. `private` :限制最严格的，仅自己可访问

    3. `protected` :仅自己和派生类可以访问

    4. `internal`:对程序集内所有类可见

    5. `protected internal`: `protected` 和 `internal` 的**合集**。

### 7.9

* 抽象成员是设计用来覆写的函数成员，用 `abstract` 修饰，没有实现代码块，被分号替代。

* 不能把 `virtual` 修饰符附加到 `abstract` 修饰符。派生类抽象方法的实现必须使用 `override` 修饰符。

### 7.11

* **密封类** 必须用作独立的类，不能被作为基类,使用 `sealed` 修饰符标注。

### 7.12

* 静态类所有的成员都是静态的。用于分组不受实例影响的数据和函数，比如创建一个包含一组数学方法的数学库。所有的成员必须是静态的，不能继承静态类，它们是密封的。

### 7.13

* 通过 `this` 关键字，可以把一个方法从类的正规方法变成另一个类的拓展方法,需求如下：

    1. 拓展方法必须被声明为 `static`。

    2. 拓展方法声明所在的类也必须被声明为 `static`

    3. 拓展方法必须包含关键字 `this` 作为它的第一个参数类型，并在后面跟着它所拓展的类的名称。  
例:
```c#
// 必须是一个静态类
static class ExtendMyData
{
    // 必须是公有和静态的
    public static double Average(this MyData md)
    {
        ...
    }
}

//调用
md.Average()
```

### 7.14

* **外部方法** 是在声明中没有实现的方法，其实现常常是用c#之外的语言编写的。 外部方法使用 `extern` 修饰符标记，而且在类的声明中没有实现，实现被分号取代。例:
  ```c#
  public static extern int GetCurrentDirectory(int size, StringBuilder buf); 
  ```

* 声明和实现的链接依赖实现，但是常常由 `DllImport` 特性完成。

## 第8章 表达式和运算符

### 8.2

* **字面量** 是原代码中书写的数字或字符串，表示一个明确类型的、固定的值。

### 8.14

* 声明隐式转换的语法如下,其中 `public` 和 `static` 修饰符是所有用户定义转换必需的:
    ```c#
    public static implicit operator TargetType(SourceType Identifier)
    {
        ...
        return ObjectTargetType;
    }
    ```

* 显式转换的语法跟隐式相同，除了 `explicit` 替换掉 `implicit` 。
  ```c#
  public static implicit operator int (LimitedInt li)
  {
      return li.TheValue;
  }
  ```

### 8.15

* 运算符重载允许定义c#运算符应该如何操作自定义类型的操作数:
  ```c#
  public static LimitedInt operator -(LimitedInt x); // 一元运算符的重载带一个单独的class类型或struct类型的参数
  public static LimitedInt operator +(LimitedInt x, double y); //二元运算符的重载带两个参数，其中一个至少必须是class或struct类型
  ```

* 运算符重载方法必须被声明为带 `static` 和 `public` 两个修饰符。

* 可以重载的运算符只有下列这些:
  ```
  一元运算符：+、-、!、-、++、--、true、false
  二元运算符：+、-、*、/、&、|、^、<<、>>、==、!=、>、<、>=、<=
  ```

### 8.16

* `typeof` 运算符返回作为它的参数的任何类型的 `System.Type` 对象。

## 第9章 语句

### 9.13

* `using` 语句帮助减少额外的运行时错误带来的潜在问题。
  ```c#
  using (ResourceType Identifier = Expression) Statement //Statement是使用资源的代码，using语句隐式产生处置该资源的代码。
  ```

## 第10章 命名空间和程序集

### 10.3

* `using` 指令词必须放在源文件的顶端，在任何类型声明之前。它们应用于当前源文件中的所有命名空间。

* `using` 别名指令允许起一个别名给命名空间或者命名空间内的一个类型
  ```c#
  using Syst = System;
  using SC = System.Console;
  ```

### 10.4

* 程序集包括:
  
  1. 清单
  
  2. 类型元数据
  
  3. CIL代码(公共中间语言代码)
  
  4. 资源

### 10.6

* 强命名程序集有一个唯一的数字签名依附于它。强命名程序集默认只能访问其他强命名程序集。

### 10.8

* 有时候我们会想把DLL放在一个中心位置，这样一个单独的拷贝就可以被系统中其他程序共享。.NET有这样的贮藏库，称为 **全局程序集缓存(GAC)** 。放进GAC的程序集称为 **共享程序集** 。GAC的位置在 Assembly 子目录下，在 Windows 系统目录中。

## 第11章 异常

### 11.2

* 异常用法
  ```
  try
  {
      ...
  }
  catch [(ExceptionType [InstID])]
  {
      ...
  }
  finally
  {
      ...
  }
  ```

### 11.3

* 当一个异常发生时，CLR创建该类型的异常对象，寻找合适catch语句处理它。所有异常根本上派生自System.Exception.

### 11.5

* 如果程序的控制流进入了一个带 `finally` 块的 `try` 语句，那么 `finally` 始终会执行，即使 `try` 中含有return语句，也会在返回之前执行 `finally` 中的语句。

### 11.9

* 如果在 `catch` 块内部 `throw` 语句不带异常对象使用，会重新抛出当前异常。

## 第12章 结构

### 12.1

* 结构跟类最重要的区别是:

    1. 类是引用类型而结构是值类型

    2. 结构是隐式密封的，这意味着它们不能被派生

### 12.2

* 跟所有的值类型一样，结构类型变量含有自己的数据，因此结构类型的变量 **不能为`null`** ,两个结构变量不能引用同一个对象。

### 12.3

* 把一个结构赋值给另一个结构，就是从一个结构中把值赋值到另一个结构。这和赋值变量不同，赋值类变量时只有引用被赋值。

### 12.4

* 结构允许有实例构造函数和静态构造函数，但不允许有析构函数。

* 要调用一个构造函数，包括隐式无参数构造函数，要使用 new 运算符，即使不从堆中分配内存也要使用 new 运算符。也可以不用 new 运算符创造结构的实例，但是这样子做有一些限制：

    1. 不能使用任何数据成员的值，直到显式设置它

    2. 不能调用任何函数成员，直到所有数据成员已被赋值。

* 在结构中初始化字段是不允许的

### 12.6

* 结构是隐式密封的，因此，不能从它们派生其他结构。结构可以使用的两个继承相关的关键字是 `new` 和 `override` ，当创建一个和基类 `System.ValueType` 的成员有相同名称的成员时使用它们。

### 12.9

* 分配结构比创建类的实例需要更少的消耗，所以使用结构代替类有时可以提高性能，但要最后注意到装箱和取消装箱的高代价。

* 预定义为简单类型(int、short、long，等等)，尽管在.NET和C#中被视为原始类型，它们在.NET中都被实现为结构。

* 结构，就像类，可以实现接口。

## 第13章 枚举

* 可以通过把冒号和类型名放在枚举名之后以使用int以外的整数类型，类型可以是除了char以外的所有整数类型,所有成员常亮都属于枚举的底层类型。
  ```
  enum TrafficLight : uLong //底层类型
  {
      ...
  }
  ```

### 13.2

* Flags特性可以提供方便的特征:

    1. 通知该枚举的成员将要被结合成位标志，而不只是作为分开的值使用。这使得浏览器更合适的解释该枚举类型的变量。

    2. 它允许一个枚举的ToString方法，以对位标志的值提供更合适的格式化。

## 第14章 数组

### 14.1

* 有两种类型的多维度数组: **矩形数组** 和 **交错数组**。

* **矩形数组**
  
  1. 某个维度的所有子数组有相同长度的多维数组。
   
  2. 不管有多少个维度，都只用一个方括号。

* **交错数组**
  
  1. 每一个子数组都是独立数组的多维数组
  
  2. 可以有不同长度的子数组
   
  3. 为数组的每一个维度使用一对方括号

### 14.4

* 声明一维数组或矩形数组，可以在类型和变量名称之间使用一对方括号。方括号内的逗号就是秩说明符，它们指定了数组的维度数。秩就是 **逗号数量加1** 。数组声明后，维度数就是固定的了，然而，维度长度直到数组实例化才会被确定。
  ```c#
  long[ ] secondArray; //一维数组  
  int[,,] firatArray;  // 三维数组
  ```

* 要实例化一维数组或矩形数组，可以使用数组创建表达式。数组创建表达式由 `new` 运算符构成，后面是基类名称和一对方括号。方括号中以逗号分隔每一个维度的长度。
  ```c#
  int[,,] arr3 = new int[3, 6, 2];
  ```

### 14.7

* 对于一维数组，可以通过在数组实例化的数组创建表达式之后包括初始化列表来设置显式初始值。数组维度是可选的，因为编译器可以通过初始化值的个数来推断长度。
  ```c#
  int[] intArr = new int[] {10,20,30,40};
  ```
  也可以显式初始化矩形数组
  ```c#
  int [,] intArray2 = new int[,] {{10, 1}, {2, 10}, {11, 9}};
  ```
  甚至可以省略创建表达式
  ```c#
  int [,] intArray2 = {{10, 1}, {2, 10}, {11, 9}};
  ```
### 14.8

* 交错数组的声明语法要求每一个维度都有一对独立的方括号，数组变量声明中的方括号数决定了数组的秩。
  ```c#
  int[][] jagArr = new int[3][]; //声明并创建顶层数组
    ...                          //声明并创建子数组
  ```

* 和其他类型的数组不同，交错数组的完全初始化不能在一个步骤中完成，每一个数组必须独立创建。
  ```c#
  int[][] Arr = new int[3][];
  Arr[0] = new int[] {10, 20, 30};
  Arr[1] = new int[] {40, 50, 60, 70};
  Arr[2] = new int[] {80, 90, 100, 110, 120};
  ```

* 由于交错数组中的子数组本身就是数组，因此交错数组中可能有矩形数组。
  ```c#
  int[][,] Arr;
  Arr = new int[3][,];
  ```

  ## 第15章 委托

  