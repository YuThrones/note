# 《C#图解教程》

## 第1章 C#和.NET框架

### 1.2 

* 严格的说，.NET 框架由两部分组成：CLR(Common Language Runtime, 公共语言运行库)和FCL(Frame Class Library, 框架类库)，不包括工具。FCL是BCL(Base Class Library, 基类库)的超集，还包括Windows Forms、 ASP.NET LINQ 以及更多命名空间。

## 第2章 C#编程概述

### 2.6

* 格式字符串语法如下:  
```c#
Console.WriteLine(格式字符串（含代替标记），替换值1，替换值2，替换值3，...);
```  
例子如下:  
```c#
Consle.WriteLine("Three integers are {1}, {0} and {1}.", 3, 6);
```

## 第3章 类型、存储和变量

### 3.8

* 对于引用类型的任何对象，它所有的数据成员都存放在堆里，无论它们是值类型还是引用类型。

## 第4章 类：基础

## 第5章 方法

### 5.2

* `var` 关键字不是某种特别类型的符号，只是句法上的速记，表示任何可以从初始化的右边推出的类型。它有一些重要条件：
    1. 只能用于本地变量，不能用于字段
    
    2. 只能在变量声明中包含初始化时使用
    
    3. 一旦编译器推断出类型，它就是固定且不能更改的。

### 5.8 

* 使用应用参数时，必须在方法的声明和调用中都使用 `ref` 修饰符。实参必须是变量，在用作实参前必须被赋值。如果是引用类型变量，可以赋值为一个引用或者null值。引用参数有以下特征:

    1. 不在栈中为形参分配新的内存

    2. 形参的名称相当于实参变量的别名，引用于实参相同的内存位置。

### 5.9

* 输出参数用于从方法体内把数据传出到调用代码，它们非常类似引用参数，有以下要求：

    1. 必须在声明和调用中都使用修饰符。输出参数的修饰符是 `out` 而不是 `ref`。

    2. 实参必须是变量，不能是其他表达式类型。

    3. 在方法内部，输出参数被读取之前必须被赋值。这意味着参数的初始值是无关的，而且没有必要在方法调用之前为实参赋值。

    4. 每个输出参数在方法返回之前必须被赋值。

### 5.10

* 参数数组允许零个或多个实参对应一个特殊的形参，参数数组的重点如下:

    1. 在一个参数列表中只能有一个参数数组

    2. 如果有，它必须是列表中最后一个

    3. 在数据类型前使用 `params` 修饰符。

    4. 在数据类型后放一组空的方括号

* int型参数数组声明语法例子:
```c#
void ListInts(param int[] inVals)
{}

//有两个调用方法提供实参

//一个逗号分隔的该数据类型元素的列表，所有元素必须是方法中声明的类型
ListInts(10, 20, 30);

//一个该数据类型的元素的一维数组
int[] intArray = {1, 2, 3};
ListInts(intArray);
```

### 5.14

* 一个类中可以有一个以上的方法拥有相同的名称，这叫做方法重载。使用相同名称的每个方法必须有一个和其他方法不相同的签名。方法的签名有以下信息组成，它们在方法声明的方法头中：

    1. 方法的名称。

    2. 参数的数目。

    3. 参数的数据类型和顺序。

    4. 参数修饰符。

* 返回类型和形参的名称**不是**签名的一部分。

## 第6章 类进阶

### 6.1

* 类成员声明语句由下列部分组成：核心声明、一组可选的修饰符（modifier）和一组可选的特性（attribute）。用于描述这个结构的语法如下。方括号表示方括号内的成分是可选的。
```
[特性] [修饰符] 核心声明
```  
如果一个声明有多个修饰符，它们可以以任何顺序放在核心声明之前。比如下面语句是语义等价的：
```c#
public static int MaxVal;
static public int MaxVal;
```

### 6.7

* 成员常量(const)和真正的静态变量不同，它没有自己的存储位置，而是在编译时被编译器替换，这种方式类似于C和C++中的#define值。

### 6.8

* 属性和字段不同，属性是一个**函数成员**。它不为数据存储分配内存。它执行代码。属性是制定的一组两个匹配的、称为**访问器的方法**。

    1. `set` 访问器用于为属性赋值。

    2. `get` 访问器用于从属性获取值。

* `set` 访问器总是：

    1. 一个单独的、隐式的值参，名称为value，与属性的类型相同。
   
    2. 一个返回类型void

* `get` 访问器总是:

    1. 没有参数。

    2. 一个数属性类型相同的返回类型。

* 可以通过忽略访问器的声明，以使一个其他的属性访问器不被定义。

### 6.10

* 构造函数也可以声明为 `static`。实例构造函数初始化类的每个新实例，而static构造函数初始化类层次的项目。通常，静态构造函数初始化类的静态字段。不能显示调用静态构造函数，它们被系统自动调用：

    1. 在类的任何实例被创建之前

    2. 在类的任何静态成员被引用之前

### 6.11 对象初始化列表

* 对象初始化列表允许在创建新的对象实例时设置字段和属性的值：

    1. 被初始化的成员在创建对象的代码中必须是可访问的（如public）

    2. 初始化在构造函数完成之后发生。

### 6.14

* 字段可以用 `readonly` 修饰符声明，其作用类似于声明一个字段为 `const` ，一旦值被设定就不能改变。`const` 字段只能在字段的声明语句中初始化，而`readonly` 字段可以在下列任意位置设置它的值:

    1. 字段声明语句，如同const

    2. 类的任何构造函数。如果是static字段，初始化必须在static构造函数中完成。

* `const` 字段的值必须在编译期决定，而 `readonly` 字段的值可以在运行期决定。

### 6.16

* 索引是一组 `get` 和 `set` 访问器，需要注意以下几点：

    1. 索引没有名称，在名称的位置是关键字`this`

    2. 参数列表在**方括号**中间

    3. 参数列表中至少必须声明一个参数
   
```c#
ReturnType this [Type param1, ...]
{
    set
    {
        SetAccessorCode
    }
    get
    {
        GetAccessorCode
    }
}
```

* 索引总是实例成员，因此不能被声明为 `static`

### 6.18

* 类的声明可以被分割成几个分部类的声明：

    1. 每个分部类的声明都含有一些类成员的声明。

    2. 类的分部类声明可以在同一个文件中也可以在不同的文件中。

* 每个局部声明必须被标为 `partial class`

## 第7章 类和继承

### 7.3

* 覆盖基类的成员可以用 `new` 关键字显式覆盖

### 7.4

* 可以使用基类访问表达式访问隐藏的基类成员，基类访问表达式由关键字 `base` 后面跟着一个点和成员的名称组成。

### 7.5

* 使用基类的引用不能 “看到” 派生类对象的其余部分，因为它通过基类的引用 “看” 这个对象。

* 可以使用基类引用调用派生类（derived class）的方法，只需满足下面的条件：

    1. 派生类的方法和基类的方法有相同的签名和返回类型。

    2. 基类的方法使用 `virtual` 标注

    3. 派生类的方法使用 `override` 标注

    4. 覆写和被覆写的方法必须有相同的可访问性，不能被覆写的方法是private等，而覆写方法是public。

    5. 不能覆写static方法或非虚方法

### 7.7

* 类的可访问性有两个级别： `public` 和 `internal` 。标记为 `internal` 的类只能被它自己所在的程序集内的类看到。不声明默认为 `internal`。

### 7.8

* 访问级别的成员声明有5中

    1. `public` ：所有类都可自由访问

    2. `private` :限制最严格的，仅自己可访问

    3. `protected` :仅自己和派生类可以访问

    4. `internal`:对程序集内所有类可见

    5. `protected internal`: `protected` 和 `internal` 的**合集**。

### 7.9

* 抽象成员是设计用来覆写的函数成员，用 `abstract` 修饰，没有实现代码块，被分号替代。

* 不能把 `virtual` 修饰符附加到 `abstract` 修饰符。派生类抽象方法的实现必须使用 `override` 修饰符。

### 7.11

* **密封类** 必须用作独立的类，不能被作为基类,使用 `sealed` 修饰符标注。

### 7.12

* 静态类所有的成员都是静态的。用于分组不受实例影响的数据和函数，比如创建一个包含一组数学方法的数学库。所有的成员必须是静态的，不能继承静态类，它们是密封的。

### 7.13

* 通过 `this` 关键字，可以把一个方法从类的正规方法变成另一个类的拓展方法,需求如下：

    1. 拓展方法必须被声明为 `static`。

    2. 拓展方法声明所在的类也必须被声明为 `static`

    3. 拓展方法必须包含关键字 `this` 作为它的第一个参数类型，并在后面跟着它所拓展的类的名称。  
例:
```c#
// 必须是一个静态类
static class ExtendMyData
{
    // 必须是公有和静态的
    public static double Average(this MyData md)
    {
        ...
    }
}

//调用
md.Average()
```

### 7.14