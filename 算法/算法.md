# 算法
## 动态规划
### 背包问题
* f[i][v]表示前i件物品恰放入一个容量为v的背包可以获得的最大价值。则其状态转移方程便是：
`f[i][v]=max{ f[i-1][v], f[i-1][v-w[i]]+v[i] }`。
可以压缩空间，`f[v]=max{f[v],f[v-w[i]]+v[i]}`

* 优化
以上方法的时间和空间复杂度均为O(N\*V），其中时间复杂度基本已经不能再优化了，但空间复杂度却可以优化到O(V）。
先考虑上面讲的基本思路如何实现，肯定是有一个主循环i=1..N，每次算出来二维数组f[i][0..V]的所有值。那么，如果只用一个数组f [0..V]，能不能保证第i次循环结束后f[v]中表示的就是我们定义的状态f[i][v]呢？
f[i][v]是由f[i-1][v]和f [i-1][v-w[i]]两个子问题递推而来，能否保证在推f[v]时（也即在第i次主循环中推f[v]时）能够得到f[v]和f[v -w[i]]的值呢？事实上，这要求在 ** 每次主循环中我们以v=V..0的顺序推f[v] ** ，这样才能保证推f[v]时f[v-w[i]]保存的是状态f[i-1][v-c[i]]的值。伪代码如下：
```
for i=1..N
for v=V..0
f[v]=max{f[v],f[v-w[i]]+v[i]};
```
其中的f[v]=max{f[v],f[v-w[i]]}一句恰就相当于我们的转移方程f[i][v]=max{f[i-1][v],f[i-1][v-w[i]]}，因为的
f[v-w[i]]就相当于原来的f[i-1][v-w[i]]。如果将v的循环顺序从上面的逆序改成顺序的话，那么则成了f[i][v]由f[i][v-w[i]]推知，与本题意不符，但它却是另一个重要的背包问题P02最简捷的解决方案，故学习只用一维数组解01背包问题是十分必要的。

### LCS最长公共子串问题
* X和Y的公共子串可以是X-1和Y的公共子串或者X和Y-1的公共子串或者X-1和Y-1的公共子串+1.

### 应用动态规划问题方法步骤：
1. 刻画一个最优解的结构特征。
2. 递归地定义最优解的值。
3. 计算最优解的值，通常采用自底向上的方法。
4. 利用计算出的信息构造一个最优解。

## 图
* 对于图G=(V,E),可以用两种表示方法，一种是将图作为**邻接链表的组合**，另一种将图作为**邻接矩阵**来看待。邻接链表在表示**稀疏图**（边的条数|E|远远小于|V²|的图）成为通常的选择，但是**稠密图**（|E|接近于|V²|）的情况下，倾向于使用邻接矩阵。
* **邻接链表**由包含|V|条链表的数组构成，每个节点有一条链表，对于u∈V，邻接链表包含所有与节点u之间有边相邻的节点v，空间存储需求为Θ（V+E）。缺陷是无法快速判断（u，v）是否是图中的一条边。
* **邻接矩阵**使用|V|×|V|的矩阵
* 广度优先搜索：
  未发现的节点是白色节点，灰色节点表示其邻接节点没有探索完，黑色代表邻接节点也已经探索完了，这个过程会产生一颗广度搜索树
* 深度优先搜索
  每次会从未发现的节点中随机选取一个作为根节点进行深度优先搜索
  会形成由多棵深度优先树构成的深度优先森林，深度优先搜索算法还会在每个节点盖上时间戳：
    1. 第一个时间戳v.d记录节点v第一次被发现的时间（涂上灰色）
    2. 第二个时间戳v.f记录的是搜索完成对v的邻接表扫描的时间（涂上黑色）

### 拓补排序
* 对于一个有向无环图G=（V,E)来说，其拓补排序是G中所有结点的一种线性次序，满足以下条件：如果图G包含边（u,v),则结点u在拓补排序中处于结点v的前面（如果G包含环路，则不可能排出一个线性次序）

### 强连通分量
* 有向图G=(V,E)的强连通分量是一个最大结点集合C⊆V，对于该集合任意一对结点u和v来说，u~v和v~u同时存在。
* 定义d(U)=min{u.d}和f(U)=max{u.f}。d(U)和f(U)分别是节点集合U中所有的结点里最早的发现时间和最晚的发现时间。
* 搜索方法
```
伪代码
Kosaraju_Algorithm:
step1：对原图G进行深度优先遍历，记录每个节点的离开时间。
step2：选择具有最晚离开时间的顶点，对反图GT进行遍历，删除能够遍历到的顶点，这些顶点构成一个强连通分量。
step3：如果还有顶点没有删除，继续step2，否则算法结束。
```

## 贪心算法
* 每一步都作出局部最优选择，但不保证得到全局最优解，每个贪心算法之下，几乎都有一个更繁琐的动态规划算法。
* 设计贪心算法的步骤
    1. 将最优化问题转化为这样的形式：对其作出选择后，只剩下一个子问题需要求解
    2. 证明作出贪心选择后，原问题总是存在最优解，即贪心选择总是安全的。
    3. 证明作出贪心选择后，剩余的子问题满足性质：其最优解与贪心选择组合即可得到原问题的最优解，这样就得到了最优子结构

## 哈夫曼树
* 哈夫曼编码步骤：
一、对给定的n个权值{W1,W2,W3,...,Wi,...,Wn}构成n棵二叉树的初始集合F= {T1,T2,T3,...,Ti,...,Tn}，其中每棵二叉树Ti中只有一个权值为Wi的根结点，它的左右子树均为空。（为方便在计算机上实现算 法，一般还要求以Ti的权值Wi的升序排列。）
二、在F中选取两棵根结点权值最小的树作为新构造的二叉树的左右子树，新二叉树的根结点的权值为其左右子树的根结点的权值之和。
三、从F中删除这两棵树，并把这棵新的二叉树同样以升序排列加入到集合F中。
四、重复二和三两步，直到集合F中只有一棵二叉树为止。
简易的理解就是，假如我有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1,那么我们第一步先取两个最小权值作为左右子树构造一个新树，即取1，2构成新树，其结点为1+2=3，如图：  
![](http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231832078695.png)  
虚线为新生成的结点，第二步再把新生成的权值为3的结点放到剩下的集合中，所以集合变成{5,4,3,3}，再根据第二步，取最小的两个权值构成新树，如图：  
![](http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231832087092.png)  
再依次建立哈夫曼树，如下图：  
![](http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231832084301.jpg)  
其中各个权值替换对应的字符即为下图：  
![](http://images.cnblogs.com/cnblogs_com/Jezze/201112/201112231832086286.jpg)  
所以各字符对应的编码为：A->11,B->10,C->00,D->011,E->010
霍夫曼编码是一种无前缀编码。解码时不会混淆。其主要应用在数据压缩，加密解密等场合。

* 同一符号可以有不同的码长，即编码方法并不唯一，其原因是两支路概率合并后重新排队时，可能出现几个支路概率相等，造成排队方法不唯一。一般，若将新合并后的支路排到等概率的最上支路，将有利于缩短码长方差，且编出的码更接近于等长码。

## 红黑树
* 红黑树是平衡搜索树的一种，可以保证在最坏情况下基本动态集合操作的时间复杂度为O(lgn)。
  红黑树是一颗二叉搜索树，他在每个节点上增加了一个存储为来表示节点的颜色，可以是RED或者BLACK，通过对任何一条从根到叶子的简单路径上各个节点的颜色进行约束，红黑树确保没有一条路径会比其他路径长出2倍，近似是平衡的。
* 树的每个节点包含5个属性：color，key，left，right，p。
* 一颗红黑树是满足以下性质的二叉搜索树：
    1. 每个节点或是红色的，或是黑色的
    2. 根节点是黑色的
    3. 每个叶节点（NIL）是黑色的
    4. 如果一个结点是红色的，则它的两个叶节点都是黑色的
    5. 对每个结点，从该结点到其后代叶节点的简单路径上，都包含相同数目的黑色结点
* 可以用一个哨兵结点来代表NIL，对于一颗红黑树T，哨兵T.nil的color颜色为BLACK，其他属性可以为任意值，所有指向NIL的结点都可以用T.nil的指针替换
* 从某个结点出发，到一个叶节点的黑色结点个数称为该节点的黑高

* 插入：
  新插入的结点着色为红色，然后进行着色调整并旋转
  **重点：**
    1. 只有可能违反两种情形，一种是根节点为红色，另一种是父节点跟子节点同时为红色
    2. 当迭代结点为黑色时迭代停止
    3. 主要有三种情形，第一种是父节点跟叔结点同时为红色，则子节点跟父节点以及叔结点的颜色都要变化。第二种跟第三种是叔结点颜色是黑色时，根据子结点是左结点还是右结点进行左旋或者右旋。

## 最小生成树
* 无向图G=(V，E)的一个**切割**是集合V的一个划分，如果一条边（u,v)∈E的一个端点位于集合S，另一个位于集合V-S，则称这条边**横跨**切割。如果集合A中不存在横跨该切割的边，则称该切割**尊重**集合A。在横跨一个切割的所有边中，权重最小的称为轻量级边。
* 每次选择一条最小安全边加入集合即可满足答案

* Kruskal
  每次选择连接不同的两棵树的边里面权重最小的那个

* Prim
  每一步加入连接不在集合中的一条最小权重的切割边加入集合中

## 单源最短路径
* Bellman-Ford算法：
  每条边被松弛V-1次
* Dijkstra算法：
  维持的关键信息是一组节点集合S。算法重复从V-S中选择最短路径估计最小的节点u，将u加入S中，然后对从u出发的所有边进行松弛。

## 差分约束系统
* 线性矩阵的每一行包括一个1和一个-1，其他所有项都为0，边的权重为不等式右边的值，G需要增加一个v0的点，从v0出发的边所有权重为0，如果图G包含权重为负值的环，则无解
* 一个可行解为x=(δ(v0,v1), δ(v0,v2), ... , δ(v0, vn))
