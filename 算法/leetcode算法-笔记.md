# leetcode算法-笔记

## 2. 排序

### 快速排序
- Partition时需要注意分割数字得是第一个，优化版本也是需要随机选一个数字跟第一个交换，因为需要保证小于区域的下一位必须是等于分割数字的，否则交换是没有意义的。

## 4. 链表

### 快慢指针求环入口
- 先准备步进为1和2的两个指针，同时向前遍历，如果遇到Null说明没有环，当两个第一次相遇之后，把快指针指向链表头，两个都以步长为1的速度再继续遍历，两个第二次相遇的结点即为入环结点。

### 求两个单向链表的第一个交点
- 这种情况要分类讨论，先求出两个链表的快慢指针入口，同时也知道了两个链表是否有环。
- 第一种情况，两个链表都无环，那么相交情况必只有以下一种，类似Y型。这种情况下，只需要从头到尾遍历两个链表，并且记录他们的尾结点和链表长度，然后对比尾结点，如果不是同一个节点说明没有相交，如果是同一个节点，则两个链表再次从头遍历，较长链表先走长度差值的次数，然后两个同时前进，遇到第一个相同节点即为交点。
	```mermaid
	flowchart TD
		A-->B
		B-->C
		C-->E
		D-->C
	```
- 第二种情况，两个链表都有环，那么相交情况有以下两种
	1. 在环外相交，这种情况可以转化为两个无环列表的相交问题，把入环节点作为尾结点即可。
	```mermaid
	flowchart TD
		A-->B
		B-->C
		C-->D
		D-->E
		E-->C
		F-->B
	```
	2. 环外不相交，但是共享环，这种情况返回任意一个入环节点都为正确。
	```mermaid
	flowchart TD
		A-->B
		E-->D
		B-->C
		C-->D
		D-->B
	```

## 5. 二叉树

### 树形DP
- 树形DP经典解题套路，是向左子树和右子树分别要信息，和自身信息整合后返回给上一层，这个方法规定了思路，也定了代码大致框架，可以很方便的解决大多数问题。

## 6. 图

### 图通用结构
```cpp
class Node{
	public:
		int in;
		int out;
		int value;
		vector<Node> next;
		vector<Edge> edge;
}
```

## 7. 贪心算法

- 贪心每道题的解法可能不一样，不要尝试从数学上证明，使用对数器和暴力解法的结果对比，判断多种贪心中较好的那种。

## 8. 哈希
- 布隆过滤器用于处理大数据的黑名单问题，可以缩小需要的内存，缺点是有会一定的误判率，而且无法避免。

- 一致性哈希的原理是把哈希的区间作为一个环，根据环的位置确定节点管理的区域，更进一步的优化是使用虚拟节点，每个机器管理一定数量的虚拟节点，通过虚拟节点来解决节点数量较少时分配不均，还有增减节点时分配不均匀的问题。

## 9. 动态规划
1. 动态规划不要一开始就想着找动态规划方程，可以先写出暴力递归解法，然后从中列出表格，并总结出依赖关系和顺序，然后把这个递归改成表格取值的形式，就是最简单的动态规划，最后再在表格基础上做进一步的时间和空间优化。
2. 动态规划一个重要的优化方式叫斜率优化，当填表时，如果有枚举行为，可以看看附近位置，是否可以用同一行的值来替换枚举的计算行为，达到减去重复计算的优化。
3. 在找暴力递归方法的尝试过程中，有两个简单的评价维度，第一个是单个可变参数的维度，选择int肯定比int数组方便很多；第二个是可变参数的个数，在第一个原则基础上越少越好。