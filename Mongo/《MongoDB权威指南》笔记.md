# 《MongoDB权威指南》笔记

## 第1章 简介

* Mongo不具备关系型数据库的所有功能，比如联接（join）等，主要是为了提高扩展性，这些不方便在分布式系统上实现。

## 第2章 入门

* 文档是MongoDB中数据的基本单元，类似于关系数据库管理系统中的行（但是比行复杂很多）

* 集合可以被看成没有模式的表

* MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。

* MongoDB自带JavaScript Shell，这个工具对于管理MongoDB实例和操作数据作用非常大。

* 每一个文档都有一个特殊的键 `_id` ，它在文档所属的集合中是唯一的。

### 2.1 文档

* 文档中的键值对是有序的。

### 2.2 集合

* 集合名不能是空字符串""， 不能含有 \0（空字符）。

* 集合名不能以"system."开头，这是为系统集合保留的前缀。
  
* 用户创建的集合名字不能含有保留字符$，除非要访问系统创建的集合，否则不要在名字里出现$。

### 2.3 数据库

* 数据库名不能含有 `" "（空格）`、`.` 、 `$`、 `/` 、 `\` 、`\0（空字符）`，并且应全部小写，最多64字节。

* 有一些数据库名是保留的，可以直接访问这些具有特殊作用的数据库。

* admin是“root”数据库，要是将一个用户添加到这个数据库，这个用户自动继承数据库所有权限，一些特殊的服务端命令也只能从这个数据库运行，比如列出所有数据库或者关闭服务器。

* local：这个数据永远不会被复制，用来存储限于本地单台服务器的人以及和。

* config：当mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。

### 2.4 启动MongoDB

* MongoDB一般作为网络服务来运行，客户端可以连接到服务器并执行操作，要启动该服务器，需要运行mongod可执行文件。

* 在没有设置的情况下，默认数据目录是`/data/db`，默认端口是`27017`。

### 2.5 MongoDB Shell

* 可以运行 mongo 启动shell连接MongoDB进行交互。

* shell开启的时候会连接到MongoDB的 `test` 数据库，并将这个数据库赋值给全局变量 `db`。

* shell还有些非JavaScript的语法的拓展，这是为了方便习惯SQL shell的用户添加的，虽然没有额外的功能，但是是很好的语法糖。

* `insert` 函数用于添加文档，加入的文档都会自动添加 `_id` 键。
  
* `find`函数会返回集合里面所有文档，如果只想查看一个，可以使用 `findOne`

* 使用 `update` 函数接受至少两个参数，一个是要更新文档的限定条件，第二个是新的文档。

* `remove` 用于从数据库中永久性删除文档，在不使用参数调用的情况下会删除集合内所有文档。

### 2.6 数据类型

* `ObjectId` 是 `_id` 的默认类型，是用 **时间戳+机器+PID+计数器** 拼接的。如果插入文档的时候没有`_id`，系统会自动创建一个，但通常由客户端完成，以减少服务器负担。此外也不需要另外查询ObjectId，可以由驱动程序直接返回。

## 第3章 创建、更新及删除文档

### 3.1 插入并保存文档

* 可以发送一个文档的数组给mongoDB进行批量插入，这样只有一个TCP请求，可以有效提高效率

* MongoDB在插入时不执行代码，因此不怕注入攻击

### 3.3 更新文档

* 更新操作是原子的，如果两个更新同时发生，会根据到达服务器顺序依次执行。

* 通常文档只有一部分要更新，利用原子的更新修改器，可以使得这部分更新更为高效，例如可以使用 `$inc` 修改器增加值。
  ```
  db.analytics.update({"url" : "www.example.com"}, {"$inc" : {"pageviews" : 1}})
  // 增加pageviews的值
  ```

* `$set` 修改器：指定一个键的值，如果这个键不存在，则创建它

* `$unset` 可以将键完全删除

* `$inc` 只能用于整数、长整数或双精度浮点数，要是在其他类型上面会操作失败。

* `$push` 会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组

* `$ne` 可以用来检查一个值是否不在数组里

* `addToSet` 可以用来往数组添加时避免重复

* 将 `$addToSet` 和 `$each` 组合起来，可以添加多个不同的值
  ```
  do.users.update({"_id": ObjectId("xxxxxxxxxxxxxxxxx)},
  {"$addToSet": {"emails" : {"$each":["joe@php.net", "joe@example.com"]}}})
  ```

* `$pull` 可以将匹配内容全部从数组中删除

* `upsert` 是一种特殊的更新，要是没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新的文档。

* 可以使用 `getLastError` 命令查看更新了多少文档。

* `findAndModify` 可以用来寻找并且修改文档。

## 第4章 查询

### 4.1 find简介

* 有时候不需要返回所有的键值对，可以通过 `find` 或者 `findOne` 的第二个参数指定想要的键。 `_id` 这个键总是会被返回，即使没有指定也一样。例如
  ```
  > db.users.find({}, {"username":1, "email":1})
  {
    "_id":ObjectId("XXXXXXX"),
    "username":"joe",
    "email":"joe#example.com",  
  }
  ```

* 也可以使用`find` 第二个参数排除某些键，包括 `_id`
  ```
  > db.users.find({}, {"username":1, "_id":0})
  ```

### 4.2 查询条件

* `$lt`、`$lte`、`$gt` 和 `$gte` 是全部的比较操作符，分别对应 `<` 、`<=` `>` 和 `>=`，可以组合起来以便查找一个范围的值
  ```
  > db.users.find({"age":{"$gte":18, "$lte":30}})
  ```

* `$ne` 表示不相等，可以用于所有类型的值。

* `$in` 用来查询一个键的多个值,相对的是 `$nin`

* `$or`可以用来完成多个键值的任意给定值
  ```
  > db.raffle.find({"$or" : [{"ticket_no": 725}, "winner": true]})
  ```
* 使用AND型查询时，总是尽可能用最少的条件限定结果范围，使用OR型正相反，第一个条件尽可能地匹配更多的文档，这样才是最为有效的。

* `$not` 是元条件语句，可以用于任何其他条件之上。
  ```
  > db.users.find({"id_num": {"$not" : {"$mod" : [5, 1]}}})
  ```
  本例返回 mod 5 不为1的结果

### 4.3 特定于类型的查询

* MongoDB使用Perl兼容的正则表达式(PCRE)库来匹配正则表达式，PCRE支持的语法都能够被MongoDB接受。

* 如果需要通过多个元素来匹配数组，需要使用 `$all`，这样就会匹配一组元素。
  ```
  > db.food.find({"fruit" : {$all : ["apple", "banana"]}})
  ```
  这样就可以返回既有"apple"又有"banana"的文档，顺序无关紧要

* `$size` 操作符可以获取指定长度数组

* `$slice`可以返回数组的一个子集合。除非特别声明，否则使用`$slice`将返回文档中的所有键。

* `$where` 可以用Javascript作为查询的一部分，使查询几乎能做任何事情。如果`$where` 值的函数返回true，文档作为结果的一部分被返回，如果为false则不然。如非必要，不要使用 `$where`,因为速度比常规查询慢很多。每个文档都要从BSON转换为JavaScript对象，然后用 `$where`的表达式来运行，还不能利用索引。

### 4.5 游标

* 数据库使用游标来返回 `find` 的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果数量，根据任意方向任意键的组合对结果进行各种排序等。

* 要限制结果数量，可在`find`之后使用`limit` 函数。`skip`函数会跳过前几个匹配的文档。`sort` 用一个对象作为参数：一组键值对。键对应文档的键名，值代表排序的方向。排序方向可以是1（升序）或者-1（降序）。`skip`大量使用对性能有很大影响，不能跳过太多。

### 4.6 游标内幕

* 在服务器端，游标消耗内存和其他资源，在游标遍历尽了结果，或者客户端发来消息要求终止，或者超过10分钟不适用之后会销毁。多数驱动程序实现了一个叫 `immortal` 的函数，或者类似机制，告知数据库不要让游标超时。

## 第5章 索引

### 5.1 索引简介

* 创建索引要使用 `ensureIndex` 方法:
  ```
  db.people.ensureIndex({"username" : 1})
  ```
  传递给 `ensuerIndex` 的文档形式与传递给 `sort` 的文档形式一样：1组值为1或者-1的键，表示索引创建的方向。

* 如果有个索引 `{"a":1, "b":1,"c":1, ... "z":1}`,实际上是有了 `{"a":1}`、`{"a":1, "b":1}`等索引，但是使用`{"c":1}`等索引的查询则不会被优化，只有使用索引前部的查询才能使用该索引。

* 创建索引的缺点就是每次插入、更新和删除时都会产生额外的开销。每个集合默认的最大索引个数为64个，能够应付绝大多数情况。

* 简历索引时要考虑如下问题：
  1. 会做什么样的查询？其中哪些键需要索引？
  2. 每个键的索引方向是怎样的？
  3. 如何应对拓展？有没有中不同的键的排列顺序可以使常用数据更多地保留在内存中？

* 索引默认名字类似 `keyname1_dir1_keyname2_dir2_.._keynameN_dirN` 这种形式，也可以通过ensureIndex的选项指定自定义名字:
  ```mongo
  > db.foo.ensureIndex({"a":1, "b":1}, {"name":"alphabet"})
  ```

### 5.2 唯一索引

* 唯一索引可以确保集合的每一个文档都有唯一值，例如:
  ```mongo
  > db.people.ensureIndex({"username":1, {"unique" : true}})
  ```
  默认情况下 `insert` 并不检查文档是否插入过了，只有用安全插入才能保证不重复。

* 当为已有的集合创建索引，可能有些值已经重复了，这种情况下索引会创建失败。可以使用 `dropDups` 保留发现的第一个文档，而删除接下来有重复值的文档。
  ```mongo
  > db.people.ensureIndex({"username":1}, {"unique":true, "dropDups":true})
  ```

* 创建符合唯一索引的时候，单个键的值可以相同，只要所有键的值组合起来不痛就好。

### 5.3 使用 explain 和 hint
* 对游标使用 `explain` 方法，就可以得到查询细节，返回一个文档而不是游标本身。

* 如果发现`MongoDB` 用了非预期的索引，可以用 `hint` 强制使用某个索引，例如
  ```
  > db.c.find({"age" : 14, "username" : /.*/}).hint({"username":1, "age":1})
  ```
  一般情况不需要指定，MongoDB的查询非常智能，在初次查询时会尝试各种方案，最先完成的被确定使用，并且记录下来以备以后使用。