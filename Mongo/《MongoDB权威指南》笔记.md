# 《MongoDB权威指南》笔记

## 第1章 简介

* Mongo不具备关系型数据库的所有功能，比如联接（join）等，主要是为了提高扩展性，这些不方便在分布式系统上实现。

## 第2章 入门

* 文档是MongoDB中数据的基本单元，类似于关系数据库管理系统中的行（但是比行复杂很多）

* 集合可以被看成没有模式的表

* MongoDB的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限。

* MongoDB自带JavaScript Shell，这个工具对于管理MongoDB实例和操作数据作用非常大。

* 每一个文档都有一个特殊的键 `_id` ，它在文档所属的集合中是唯一的。

### 2.1 文档

* 文档中的键值对是有序的。

### 2.2 集合

* 集合名不能是空字符串""， 不能含有 \0（空字符）。

* 集合名不能以"system."开头，这是为系统集合保留的前缀。
  
* 用户创建的集合名字不能含有保留字符$，除非要访问系统创建的集合，否则不要在名字里出现$。

### 2.3 数据库

* 数据库名不能含有 `" "（空格）`、`.` 、 `$`、 `/` 、 `\` 、`\0（空字符）`，并且应全部小写，最多64字节。

* 有一些数据库名是保留的，可以直接访问这些具有特殊作用的数据库。

* admin是“root”数据库，要是将一个用户添加到这个数据库，这个用户自动继承数据库所有权限，一些特殊的服务端命令也只能从这个数据库运行，比如列出所有数据库或者关闭服务器。

* local：这个数据永远不会被复制，用来存储限于本地单台服务器的人以及和。

* config：当mongo用于分片设置时，config数据库在内部使用，用于保存分片的相关信息。

### 2.4 启动MongoDB

* MongoDB一般作为网络服务来运行，客户端可以连接到服务器并执行操作，要启动该服务器，需要运行mongod可执行文件。

* 在没有设置的情况下，默认数据目录是`/data/db`，默认端口是`27017`。

### 2.5 MongoDB Shell

* 可以运行 mongo 启动shell连接MongoDB进行交互。

* shell开启的时候会连接到MongoDB的 `test` 数据库，并将这个数据库赋值给全局变量 `db`。

* shell还有些非JavaScript的语法的拓展，这是为了方便习惯SQL shell的用户添加的，虽然没有额外的功能，但是是很好的语法糖。

* `insert` 函数用于添加文档，加入的文档都会自动添加 `_id` 键。
  
* `find`函数会返回集合里面所有文档，如果只想查看一个，可以使用 `findOne`

* 使用 `update` 函数接受至少两个参数，一个是要更新文档的限定条件，第二个是新的文档。

* `remove` 用于从数据库中永久性删除文档，在不使用参数调用的情况下会删除集合内所有文档。

### 2.6 数据类型

* `ObjectId` 是 `_id` 的默认类型，是用 **时间戳+机器+PID+计数器** 拼接的。如果插入文档的时候没有`_id`，系统会自动创建一个，但通常由客户端完成，以减少服务器负担。此外也不需要另外查询ObjectId，可以由驱动程序直接返回。

## 第3章 创建、更新及删除文档

### 3.1 插入并保存文档

* 可以发送一个文档的数组给mongoDB进行批量插入，这样只有一个TCP请求，可以有效提高效率

* MongoDB在插入时不执行代码，因此不怕注入攻击

### 3.3 更新文档

* 更新操作是原子的，如果两个更新同时发生，会根据到达服务器顺序依次执行。

* 通常文档只有一部分要更新，利用原子的更新修改器，可以使得这部分更新更为高效，例如可以使用 `$inc` 修改器增加值。
  ```
  db.analytics.update({"url" : "www.example.com"}, {"$inc" : {"pageviews" : 1}})
  // 增加pageviews的值
  ```

* `$set` 修改器：指定一个键的值，如果这个键不存在，则创建它

* `$unset` 可以将键完全删除

* `$inc` 只能用于整数、长整数或双精度浮点数，要是在其他类型上面会操作失败。

* `$push` 会向已有的数组末尾加入一个元素，要是没有就会创建一个新的数组

* `$ne` 可以用来检查一个值是否不在数组里

* `addToSet` 可以用来往数组添加时避免重复

* 将 `$addToSet` 和 `$each` 组合起来，可以添加多个不同的值
  ```
  do.users.update({"_id": ObjectId("xxxxxxxxxxxxxxxxx)},
  {"$addToSet": {"emails" : {"$each":["joe@php.net", "joe@example.com"]}}})
  ```

* `$pull` 可以将匹配内容全部从数组中删除

* `upsert` 是一种特殊的更新，要是没有文档符合更新条件，就会以这个条件和更新文档为基础创建一个新的文档。

* 可以使用 `getLastError` 命令查看更新了多少文档。

* `findAndModify` 可以用来寻找并且修改文档。

## 第4章 查询

### 4.1 find简介

* 有时候不需要返回所有的键值对，可以通过 `find` 或者 `findOne` 的第二个参数指定想要的键。 `_id` 这个键总是会被返回，即使没有指定也一样。例如
  ```
  > db.users.find({}, {"username":1, "email":1})
  {
    "_id":ObjectId("XXXXXXX"),
    "username":"joe",
    "email":"joe#example.com",  
  }
  ```

* 也可以使用`find` 第二个参数排除某些键，包括 `_id`
  ```
  > db.users.find({}, {"username":1, "_id":0})
  ```

### 4.2 查询条件

* `$lt`、`$lte`、`$gt` 和 `$gte` 是全部的比较操作符，分别对应 `<` 、`<=` `>` 和 `>=`，可以组合起来以便查找一个范围的值
  ```
  > db.users.find({"age":{"$gte":18, "$lte":30}})
  ```

* `$ne` 表示不相等，可以用于所有类型的值。

* `$in` 用来查询一个键的多个值,相对的是 `$nin`

* `$or`可以用来完成多个键值的任意给定值
  ```
  > db.raffle.find({"$or" : [{"ticket_no": 725}, "winner": true]})
  ```
* 使用AND型查询时，总是尽可能用最少的条件限定结果范围，使用OR型正相反，第一个条件尽可能地匹配更多的文档，这样才是最为有效的。

* `$not` 是元条件语句，可以用于任何其他条件之上。
  ```
  > db.users.find({"id_num": {"$not" : {"$mod" : [5, 1]}}})
  ```
  本例返回 mod 5 不为1的结果

### 4.3 特定于类型的查询

* MongoDB使用Perl兼容的正则表达式(PCRE)库来匹配正则表达式，PCRE支持的语法都能够被MongoDB接受。

* 如果需要通过多个元素来匹配数组，需要使用 `$all`，这样就会匹配一组元素。
  ```
  > db.food.find({"fruit" : {$all : ["apple", "banana"]}})
  ```
  这样就可以返回既有"apple"又有"banana"的文档，顺序无关紧要

* `$size` 操作符可以获取指定长度数组

* `$slice`可以返回数组的一个子集合。除非特别声明，否则使用`$slice`将返回文档中的所有键。

* `$where` 可以用Javascript作为查询的一部分，使查询几乎能做任何事情。如果`$where` 值的函数返回true，文档作为结果的一部分被返回，如果为false则不然。如非必要，不要使用 `$where`,因为速度比常规查询慢很多。每个文档都要从BSON转换为JavaScript对象，然后用 `$where`的表达式来运行，还不能利用索引。

### 4.5 游标

* 数据库使用游标来返回 `find` 的执行结果。客户端对游标的实现通常能够对最终结果进行有效的控制。可以限制结果数量，根据任意方向任意键的组合对结果进行各种排序等。

* 要限制结果数量，可在`find`之后使用`limit` 函数。`skip`函数会跳过前几个匹配的文档。`sort` 用一个对象作为参数：一组键值对。键对应文档的键名，值代表排序的方向。排序方向可以是1（升序）或者-1（降序）。`skip`大量使用对性能有很大影响，不能跳过太多。

### 4.6 游标内幕

* 在服务器端，游标消耗内存和其他资源，在游标遍历尽了结果，或者客户端发来消息要求终止，或者超过10分钟不适用之后会销毁。多数驱动程序实现了一个叫 `immortal` 的函数，或者类似机制，告知数据库不要让游标超时。

## 第5章 索引

### 5.1 索引简介

* 创建索引要使用 `ensureIndex` 方法:
  ```
  db.people.ensureIndex({"username" : 1})
  ```
  传递给 `ensuerIndex` 的文档形式与传递给 `sort` 的文档形式一样：1组值为1或者-1的键，表示索引创建的方向。

* 如果有个索引 `{"a":1, "b":1,"c":1, ... "z":1}`,实际上是有了 `{"a":1}`、`{"a":1, "b":1}`等索引，但是使用`{"c":1}`等索引的查询则不会被优化，只有使用索引前部的查询才能使用该索引。

* 创建索引的缺点就是每次插入、更新和删除时都会产生额外的开销。每个集合默认的最大索引个数为64个，能够应付绝大多数情况。

* 简历索引时要考虑如下问题：
  1. 会做什么样的查询？其中哪些键需要索引？
  2. 每个键的索引方向是怎样的？
  3. 如何应对拓展？有没有中不同的键的排列顺序可以使常用数据更多地保留在内存中？

* 索引默认名字类似 `keyname1_dir1_keyname2_dir2_.._keynameN_dirN` 这种形式，也可以通过ensureIndex的选项指定自定义名字:
  ```mongo
  > db.foo.ensureIndex({"a":1, "b":1}, {"name":"alphabet"})
  ```

### 5.2 唯一索引

* 唯一索引可以确保集合的每一个文档都有唯一值，例如:
  ```mongo
  > db.people.ensureIndex({"username":1, {"unique" : true}})
  ```
  默认情况下 `insert` 并不检查文档是否插入过了，只有用安全插入才能保证不重复。

* 当为已有的集合创建索引，可能有些值已经重复了，这种情况下索引会创建失败。可以使用 `dropDups` 保留发现的第一个文档，而删除接下来有重复值的文档。
  ```mongo
  > db.people.ensureIndex({"username":1}, {"unique":true, "dropDups":true})
  ```

* 创建符合唯一索引的时候，单个键的值可以相同，只要所有键的值组合起来不痛就好。

### 5.3 使用 explain 和 hint
* 对游标使用 `explain` 方法，就可以得到查询细节，返回一个文档而不是游标本身。

* 如果发现`MongoDB` 用了非预期的索引，可以用 `hint` 强制使用某个索引，例如
  ```
  > db.c.find({"age" : 14, "username" : /.*/}).hint({"username":1, "age":1})
  ```
  一般情况不需要指定，MongoDB的查询非常智能，在初次查询时会尝试各种方案，最先完成的被确定使用，并且记录下来以备以后使用。

### 5.4 索引管理

* 索引的元信息储存在每个数据库的 `system.indexes` 集合中，这是一个保留集合，不能对其插入或者删除文档。操作只能通过 `ensureIndex` 或者 `dropIndexes` 进行。

* `system.indexes` 集合包含每个索引的详细信息，同时 `system.namespaces` 也含有索引的名字。system.namespaces 类似:
  ```
  {"name": "test.foo"}
  {"name": "test.foo.$_id_"}
  ```

* 为已有文档创建索引比先创建索引再插入所有文档要稍快一些。

### 5.5 地理空间索引

* 假设要找到给定经纬度坐标附近的咖啡馆，就需要创建专门的索引提高这种查询的效率，同样适用 `ensureIndex` 来创建，不过蚕食不是1或者-1， 是“2d”。
  ```
  > dp.map.ensureIndex({"gps":"2d"})
  ```

* "gps" 键的值必须是某种形式的一对值，一个包含两个元素的数组或者是包含两个键的内嵌文档都是有效的。

* 一般地理空间索引假设值的范围是-180 ~ 180，可以通过 `ensureIndex` 的选项来指定最大最小值
  ```
  > db.star.ensureIndex({"light-years" : "2d"}, {"min":-1000, "max":1000})
  ```

* 地理空间查询以两种方式进行：普通查询（用find）或者使用数据库命令。 `find` 的方式与一般的查询差别不大，不过使用了 "$near"，需要两个目标值的数组作为参数
  ```
  > db.map.find({"gps":{"$near":[40, -73]}})
  ```
  也可以使用 `geoNear` 完成相同操作
  ```
  > db.runCommand({geoNear:"map", near[40, -73], num:10})
  ```
  `geoNear` 会返回每个文档到查询点距离，但是`find` 不会，不过若是结果大于4MB，这是唯一选择。
  把"$near" 换乘 "$within"可以找到指定形状内的文档。

* 应用要找的东西往往不只是一个地点，可以将地理空间索引和普通索引组合满足需求。
  ```
  > db.ensureIndex({"location" : "2d", "desc" : 1})
  ```

## 第6章 聚合

### 6.1 count

* `count` 是最简单的聚合工具，返回集合中的文档数量:
  ```
  > db.foo.count()
  ```
  不论集合多大，都会很快返回总的文档数量，但是增加查询条件会变慢
  ```
  > db.foo.count({"x":1})
  ```

### 6.2 distinct

* `distinct` 用来找出给定键的所有不同的值，使用时必须指定集合和键。
  ```
  > db.runCommand({"distinct": "people", "key" : "age"}})
  ```

### 6.3 group

* `group` 做的聚合选定分组依据的键，根据键值不同分成若干组，可以聚合每一组内的文档，产生一个结果文档。
  ```
  > db.runCommand({
    "ns" : "stocks",
    "key" : "day",
    "initial" : {"time" : 0},
    "$reduce" : function(doc, prev) {
      if (doc.time > prev.time) {
        prev.price = doc.price;
        prev.time = doc.time;
      }  
    "condition" : {"day" : {"$gt" : "2010/09/30"}}
    }})
  ```

* `"ns" : " stocks"` 指定要分组的集合。
  
* `"key" : "day"` 指定文档分组依据的键。

* `"initial" : {"time" : 0}` 每一组 `reduce` 函数调用的初始时间，会作为初始文档传递给后续过程。每一组的所有成员都会使用这个累加器，所以改变会保留住。
  
* `"$reduce" : function(doc, prev) {...}` 每个文档都对应一次这个调用。系统会传递两个参数：当前文档和累加器文档（本组当前的结果）

* `condition` 的作用是只处理满足条件的文档。

* 有的文档没有依据的键，就都会被分到一组，相应的部分使用 "day : null" 这样的形式，在 "condition" 中加入 `"day" : {"$exists" : true}` 就可以去掉这组。

* 完成器(finalizer)用以精简从数据库传到用户的数据，可以在每组结果传递到客户端之前被调用一次。
  ```
  > db.runCommand({"group":{
    ...
    "finalize" : function(prev) {
      var mostPopular = 0;
      for (i in prev.tags) {
        if (prev.tags[i] > mostPopular){
          prev.tag = i;
          mostPopular = prev.tags[i];
        }
      }
    }
  }})
  ```

* 可以使用 `$keyf` 键定义分组函数:
  ```
  > db.posts.group("ns":"posts",
  ... "$keyf" :function(x) {return x.category.toLowerCase();},
  ...)
  ```

### 6.4 MapReduce

* count、distinct、group能做的上述事情 MapReduce都能做，是一个可以轻轻并行化到多个服务器的聚合方法，它会拆分问题，将各个部分发送到不同的机器上，让每台机器都完成一部分。

* MapReduce有几个步骤，最开始是映射(map)，将操作映射到集合中的每个文档，这个从操作要么“无作为”，要么“产生一些键和X个值”。然后是中间环节，称作洗牌（shuffle），按照键分组，并将产生的键值组成列表放到对应的键中。化简(reduce)这把列表中的值华建伟一个单值并返回，接着进行洗牌，知道每个键的列表都只有一个值，也就是最后结果。

* MapReduce的代价是速度，比group还慢，不能用在实时环境中。

## 第7章 进阶指南

### 7.1 数据库命令

* 命令的响应是作为结果的一个文档，包含了命令是否成功执行，可能还有其他的输出信息。命令的响应应该总是包含“ok”这个键。如果“ok”的值是true则代表命令成功，否则代表命令执行出了问题，而且会有一个“errmsg”的键，表示命令失败的原因。

* MongoDB中的命令其实是作为一种特殊类型的查询来实现的，这些查询针对 `$cmd` 集合来执行。 `runCommand` 仅仅是接受命令文档，执行等价查询，因此drop调用实际上是这样的：
  ```
  db.$cmd.findone({"drop":"test"})
  ```

* 在 shell中运行 `db.listCommands()` 可以获取所有命令的列表

### 7.2 固定集合

* 固定集合要事先创建，而且大小固定，很像环形队列，如果空间不足，最早的文档就会被删除。默认情况下固定集合没有索引，即便是“_id”上也没有索引。

* 对固定集合进行插入速度极快，无需额外分配空间，实际上是一个简单的memcpy。

* 按照插入顺序输出的查询速度极快，默认情况下对固定集合进行查找都会以插入顺序返回结果。

* 固定集合能够在新数据插入时自动淘汰最早的数据。这些特点组合起来特别适合像日志这种应用场景。

* 可以使用`createCollection` 来创建
  ```
  > db.createCollection("my_collection", {capped:true, size:100000, max:100});
  ```
  当指定文档数量上限时，必须同时指定大小，淘汰机制只有容量没满的时候才会根据文档数量来工作，要是满了会根据容量来工作。

* 还可以通过转换已有的普通集合的方式来创建固定集合。

### 7.3 GridFS：存储文件

* `GridFS` 是一种在MongoDB中存储大二进制文件的机制。使用个原因有如下几个:
  1. 使用 `GridFS` 可以简化需求，如果已经使用了MongoDB，`GridFS` 可以不需要使用独立文件存储结构
  2. `GridFS` 会直接利用业已建立的赋值或分片机制，对于文件存储来说故障恢复和拓展都很容易。
  3. `GridFS` 可以避免用于存储用户上传内容的文件系统出现的某些问题。
  4. `GridFS` 不产生磁盘碎片，因为 `MongoDB` 分配数据文件空间时以 2GB 为一块。

* 最简单的使用 `GridFS` 的方法就是利用 `mongofiles` 实用程序。像其他命令行工具一样，可以执行 `mongofiles --help` 可以查看可用选项。

* `GridFS` 的一个基本思想就是可以将大文件分成很多块，每块作为一个单独的文档存储，这样就能存大文件了。除了存储文件本身的块，还有一个单独的文档用来存储分块的信息和文件的元数据。默认情况下，块使用`fs.chunks` 集合，这个块集合里面文档的结构是非常简单的:
  ```
  {
    "_id": ObjectId("..."),
    "n" : 0,
    "data" : BinData("..."),
    "files_id" : ObjectId("...")
  }
  ```
  "files_id" 是包含这个块元数据的文件文档的"_id","n"表示块编号，也就是这个块在原文件中的顺序编号。最后"data"包含组成文件块的二进制数据。

* 文件的元数据放在另一个集合中，默认是fs.files。这里面的每个文档代表`GridFS` 中的一个文件，与文件相关的自定义元数据也可以存在其中。

### 7.4 服务器端脚本

* 在服务器端可以通过`db.eval` 函数来执行 JavaScript脚本,也可以把JavaScript脚本保存在数据库中，然后再别的数据库命令中调用。

* 每个MongoDB的数据库中都有一个特殊的集合，叫做system.js,用来存放JavaScript变量。这些变量可以在任何MongoDB的JavaScript上下文中调用，包括 “$where”子句，db.eval调用，MapReduce作业。

### 7.5 数据库引用

* `DBRef 就像URL，唯一确定一个到文档的引用。是一个内嵌文档。DBRef有一些必选键:
  ```
  {"$ref" : collection, "$id" : id_value}
  ```
  DBRef中的键不能变，第一个必须是"$ref"，接着是"$id"，然后是（可选的）"$db"。

## 第8章 管理

### 8.1 启动和停止MongoDB

* 执行 `mongod` 启动MongoDB服务器，可以使用 `mongod --help` 查看所有选项。

* 可以使用 `kill` 这种命令发出信号，但是不要发送 `kill -9`，否则数据库会直接关闭，导致数据文件损毁。

* 在命令行的 `admin` 数据库使用 `shutdown` 可以稳妥的关闭数据库。

### 8.2 监控

* 默认情况下，启动`mongod` 还会启动一个基本的HTTP服务器，该服务器监听的端口号比主服务的端口号大1000，可以查看MongoDB的一些基本信息。

### 8.3 安全与认证

* 如果开启了安全性检查，只有数据库认证用户才能执行读或者写操作。`admin`数据库中的用户被视为管理员。

### 8.4 备份和修复

* `mongodump` 是一种能在运行时备份的方法，它是对运行的MongoDB做查询，然后将查到的所有文档写入磁盘。

* MongoDB提供了从备份中恢复数据的工具 `mongorestore`。 `mongorestore` 获取 `mongodump`的输出结果，将备份的数据插入到运行的MongoDB中。

* `fsync` 命令会强制服务器将所有缓冲区写入磁盘，还可以选择上锁阻止对数据库的进一步写入直到释放锁位置。

* mongo的修复过程很简单，将所有文档导出然后导入，忽略那些无效文档，完成之后重新建立索引，数据量很大的话会花很多时间

## 第9章 复制

### 9.1 主从复制

* 运行 `mongod --master` 就启动了主服务器，运行 `mongod --slave --source master_address` 就启动了从服务器，其中 `master_address` 就是主节点的地址。

* 可以不在启动时指定源，在sources数据库中插入
  ```
  > db.sources.insert({"host" : "prod.example.com:27017"})
  ```

### 9.2 副本集

* 副本集（Replica Set）就是有自动故障恢复功能的主从集群。主从集群和副本集最为明显的区别是副本集没有固定的“主节点”：整个集群会选举出一个“主节点”，当其不能工作时则变更到其他节点。

* `--replSet` 是个没接触过的选项，作用是让服务器知晓这个副本集还有其他的同伴。

* 有几种不同类型的节点可以存在副本集中：
  1. standad 这种事常规节点，存储一份完整的数据副本，参与选举投票，有可能成为活跃节点。
  2. passive 存储了完整的数据副本，参与投票，不能成为活跃节点。
  3. arbiter 仲裁者只参与投票，不接收复制的数据，也不能成为活跃节点。

### 9.3 在从服务器上执行操作

* 可以将查询放到从节点上，减轻主节点负载，对于读取密集型是非常不错的方案。

### 9.4 工作原理

* 主节点记录在其上执行的所有操作，从节点定期轮询主节点获得这些操作，然后对自己的数据副本执行这些操作。

* 主节点的操作记录叫oplog(operation log的简写)。oplog存在local数据库中的$main集合里面，每个文档都代表主节点上执行的一个操作。包含的键如下:
  1. `ts` 操作的时间戳，是一种内部类型
  2. `op` 操作类型，只有1字节代码
  3. `ns` 执行操作的命名空间
  4. `o` 进一步指定要执行的操作的文档。

### 9.5 管理

* 如果已经发现oplog大小不合适，最简单的做法就是停掉主节点，删掉local数据库的文件，用新的设置(--oplogSize)重新启动。