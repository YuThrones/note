# 《重构，改善既有代码的设计》

## 第1章 重构，第一个案例

### 1.2

* 重构之前，首先检查自己是否有一套可靠的测试机制。这些测试必须有自我检验能力。

### 1.3

* 第一个步骤是找出代码的逻辑泥团并运用到 **Extract Method**。首先，得找出函数内的 **局部变量和参数**。任何 **不会** 被修改的变量都可以 **当成参数传入新的函数**。会被修改的变量需要格外小心，如果只有一个变量被修改，可以把它 **当作返回值**。

* 一些临时变量的使用，可以改成使用查询函数来进行，虽然这样可能带来性能上的代价，需要根据实际情况取舍。

### 1.4

* 最好不要在另一个对象的属性基础上运用 `switch` 语句，如果不得不使用，也应该在对象自己的数据上用。

## 第2章 重构原则

### 2.1

* 重构(名词)：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。

* 重构(动词)：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。

### 2.3

* 事不过三，三则重构

### 2.4

间接层的作用:

1. 允许逻辑共享。

2. 分开解释意图和实现。

3. 隔离变化。

4. 封装条件逻辑。

## 第3章 代码的坏味道

### 3.1 Duplicated Code(重复代码)

1. 最简单的就是同一个类的两个函数有相同表达式，这时候可以用 **Extract Method** 提炼出重复的代码，然后让这两个地点都调用提炼出来的那一段代码。

2. 两个互为兄弟的子类内含相同表达式，对两个类都使用 **Extract Method** ，然后对提炼出来的代码使用 **Pull Up Method**， 将它推入超类内。 
3. 如果两个毫不相关的类出现 **Duplicated Code** ，应该考虑把重复代码提炼到其中一个类或者第三个类。

### 3.2 Long Method(过长函数)

* 每当感觉需要以注释来说明点什么的时候，就把需要说明的东西写进一个独立的函数内，并以其 **用途** (并非实现手法)命名。只要函数名称能解释其用途，应该毫不犹豫的这么做。关键不在于函数的长度，而在于函数“做什么”和“如何做”之间的语义距离。

### 3.3 Large Class(过大的类)

* 一个类内如果有太多实例变量或者代码，往往可以使用 **Extract Class** 和 **Extract Subclass** 提炼。

### 3.4 Long Parameter List(过长参数列)

* 对于太长的参数列，可以传入一个对象，让函数自己从对象中获取数据。

### 3.5 Divergent Change(发散式变化)

* 我们希望软件更容易被修改，一旦需要修改，我们希望能跳转到一个点，只在该处做修改，如果不能做到，就要注意了。如果某个类经常因为不同的原因在不同的方向上变化， **Divergent Change** 就出现了。针对某一外界变化的所有相应修改都应该只发生在单一类中，而这个类内的所有内容都应该反应此变化。

### 3.6 Shotgun Surgery(霰弹式修改)

* **Shotgun Surgery** 类似 **Divergent Change**。 如果遇到某种变化，都必须在许多不同的类内作出许多小的修改，你面临的坏味道就是 **Shotgun Surgery(霰弹式修改)**。

* **Divergent Change** 是指 “一个类受多种变化的影响”， **Shotgun Change** 则是指一种变化引发多个类相应修改。这两种情况下都应该整理代码，使“外界变化”与“需要修改的类”趋于一一对应。

### 3.7 Feature Envy(依恋情节)

* 一种经典的气味是：函数对某个类的兴趣高过自己所处类的兴趣。

### 3.8 Data Clumps(数据泥团)

* 总是绑在一起出现的数据应该拥有属于他们自己的对象，这样可以减少字段和参数的个数。

### 3.9 Primitive Obsession(基本类型偏执)

### 3.10 Switch Statements(Switch惊悚现身)

* 看到switch语句的时候，多数应该以多态替代，或者把分支的执行拆分成函数。

### 3.11 Parallel Inheritance Hierarchies(平行继承体系)

* 这是 **Shotgun Surgery** 的一种特殊情况。这种情况下每为一个类增加一个子类，也必须为另一个类增加一个子类。这种情况下一般策略是：让一个继承体系的实例引用另一个继承体系的实例。

### 3.12 Lazy Class(冗余类)

### 3.13 Speculative Generality(跨跨其谈未来性)

* 如果以总有一天需要做这事，并因而企图以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了。如果函数或类的唯一用户是测试用例，那就飘出了这种坏味道。

