# 随手笔记

## 图的搜索

### 最短路径

1. Bellman-Ford算法  
循环遍历所有边，尝试用边去更新其他节点，在一次循环后没有任何更新时停止。最多更新n次，如果第n+1次还更新了，说明存在负圈，n等于节点数目。复杂度为O(|V|\*|E|)

2. Dijkstra算法  
不能用于存在负边的情况，每次只用最短距离已经确定的顶点更新其他顶点，使用堆可以达到O(|E|log|V|)的复杂度。

3. Floyd-Warshall算法  
通过简单的三重循环遍历求取任意两点的最短路距离，复杂度为O(|V|\*\*3)。

### 最小生成树
1. Prim算法  
从某个顶点出发，不断贪心选择当前树与其他顶点之间相连的最小权值的边，不断进行这个操作得到的就是最小生成树，如果使用堆复杂度为O(|E|log|V|)。

2. Kruskal算法  
将边从小到大排序，将不产生圈和重边的边加入生成树中，复杂度是O(|E|log|V|)。
