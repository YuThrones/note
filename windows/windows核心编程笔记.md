# Windows核心编程笔记

## 第3章 内核对象

### 3.1
* 每个内核对象只是内核分配的一个**内存块**,并且**只能由该内核访问**。该内存块是一种**数据结构**,它的成员负责维护该对象的各种信息。有些数据成员(如安全性描述符、使用计数等)在所有对象类型中是相同的,但大多数数据成员属于特定的对象类型。例如,进程对象有一个进程 I D、一个基本优先级和一个退出代码,而文件对象则拥有一个字节位移、一个共享模式和一个打开模式。

* 我们**不能直接操纵**内核对象，Windows提供了一组函数,以便用定义得很好的方法来对这些结构进行操作。这些内核对象始终都可以通过这些函数进行访问。当调用一个用于创建内核对象的函数时,该函数就返回一个用于标识该对象的句柄。该句柄可以被视为一个**不透明值**,你的**进程中的任何线程**都可以使用这个值。如果将该句柄值传递给**另一个进程**中的一个线程(使用某种形式的进程间的通信)那么这另一个进程使用你的进程的句柄值所作的调用就会**失败**。但是有3种机制,能使多个进程能够成功地**共享**单个内核对象。

* 内核对象由内核所拥有,而不是由进程所拥有。如果你的进程调用了一个创建内核对象的函数,然后你的进程终止运行,那么内核对象**不一定被撤消**。内核知道有多少进程正在使用某个内核对象,因为每个对象包含一个**使用计数**。使用计数是所有内核对象类型常用的数据成员之一。如果内核对象的使用计数降为 0,内核就撤消该对象。这样可以确保在没有进程引用该对象时系统中不保留任何内核对象。

* 内核对象能够得到**安全描述符**的保护。安全描述符用于描述谁创建了该对象,谁能够访问或使用该对象,谁无权访问该对象。用于创建内核对象的函数几乎都有一个指向 SECURITY_ATTRIBUTES结构的指针作为其参数,下面显示了CreateFileMapping函数的指针:
```
HANDLE CreateFileMapping(
	HANDLE hFile,
	PSECURITY_ATTRIBUTES psa,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	PCTSTR pszName);
```  
SECURITY_ATTRIBUTES结构类似下面的样子:  
```
typedef struct _SECURITY_ATTRIBUTES {
	DWORD nLength;
	LPVOID lpSecurityDescriptor;
	BOOL bInheritHandle;
} SECURITY_ATTRBUTES;
```
* 要确定一个对象是否属于内核对象,最容易的方法是观察创建该对象所用的函数。创建内核对象的所有函数几乎都有一个参数,你可以用来设定安全属性的信息,用于创建用户对象或GDI对象的函数都没有PSECURITY_ATTRIBUTES参数。

### 3.2
* 当一个进程被初始化时,系统要为它分配一个**句柄表**。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。当进程初次被初始化时,它的句柄表是空的。每当调用一个将内核对象句柄接受为参数的函数时,就要传递由一个Create\*&函数返回的值。从内部来说,该函数要查看进程的句柄表,以获取要生成的内核对象的地址,然后按定义得很好的方式来生成该对象的数据结构。
如 果 传 递 了 一 个 无 效 索 引(句柄),该函数便返回失败,而GetLastError 则返回6(ERROR\_INVALID\_HANDLE)。由于句柄值实际上是放入进程句柄表的索引,因此这些句柄是与进程相关的,并且不能由其他进程成功地使用。

* 无论怎样创建内核对象,都要向系统指明将通过调用CloseHandle来结束对该对象的操作:  
```
BOOL CloseHandle(HANDLE hobj);
```

* 应用程序在**运行时有可能**泄漏内核对象,但是当进程终止运行时,系统将能确保所有内容均被正确地清除。另外,这个情况适用于所有对象、资源和内存块,也就是说,当进程**终止运行**时,系统将保证进程**不会留下任何对象**。

### 3.3
* 许多情况下,在不同进程中运行的线程需要共享内核对象。下面是为何需要共享的原因:  
  * 文件映射对象使你能够在同一台机器上运行的两个进程之间共享数据块。
  * 邮箱和指定的管道使得应用程序能够在连网的不同机器上运行的进程之间发送数据块。
  * 互斥对象、信标和事件使得不同进程中的线程能够同步它们的连续运行,这与一个应用程序在完成某项任务时需要将情况通知另一个应用程序的情况相同。
  
* 只有当进程具有父子关系时,才能使用对象句柄的继承：
  * 首先,当父进程创建内核对象时,必须向系统指明,它希望对象的句柄是个可继承的句柄。请记住,虽然内核对象句柄具有继承性,但是内核对象本身不具备继承性。若要创建能继承的句柄,父进程必须指定一个 SECURITY\_ATTRIBUTES结构并对它进行初始化。如果将 bIheritHandle成员置为TRUE，对象变为可继承。
  * 使用对象句柄继承性时要执行的下一个步骤是让父进程生成子进程。这要使用Create Process函数来完成。对象句柄的继承性只有在生成子进程的时候才能使用。如果父进程准备创建带有可继承句柄的新内核对象,那么已经在运行的子进程将无法继承这些新句柄。
  * 子进程不知道它已经继承了任何句柄。只有在另一个进程生成子进程时记录了这样一个情况,即它希望被赋予对内核对象的访问权时,才能使用内核对象句柄的继承权。也就是说，必须传递给子进程句柄的值子进程才知道用这个值去访问对象。
  
* 共享跨越进程边界的内核对象的第二种方法是给对象命名。
  * 下列函数都可以创建命名的内核对象：
    * CreateMutex
    * CreateEvent
    * CreateSemaphore
    * CreateWaitableTimer
    * CreateFileMapping
    * CreateJobObject
  通过传递参数给pszName这个最后的参数，可以给对象命名，但是无法保证一个同名对象是否已经存在。
  * 在第二个进程调用Create\*函数后，立刻调用GetLastError，可以知道是创建了新的对象还是打开了一个现有的对象：  
```
if (GetLastError() == ERROR\_ALREADY\_EXISTS) {
}
```  
  * 进程按名字共享对象的另一种方法是不适用Create\*函数，而是调用Open\*函数中的某一个来打开已存在的内核对象。Create\*函数跟Open\*函数的主要区别是如果对象不存在，Create\*函数将创建对象，而Open\*函数则运行失败。
  
* 共享跨越进程边界的内核对象的最后一个方法是使用DuplicateHandle函数:  
```
BOOL DuplicateHandle(
	HANDLE hSourceProcessHandle,
	HANDLE hSourceHandle,
	HANDLE hTargetProcessHandle,
	PHANDLE phTargetHandle,
	DWORD dwDesiredAccess,
	BOOL bInheritHandle,
	DWORD dwOptions);
```
简单说来,该函数取出一个进程的句柄表中的项目,并将该项目拷贝到另一个进程的句柄表中。DuplicateHandle函数配有若干个参数,但是实际上它是非常简单的。 DuplicateHandle函数最普通的用法要涉及系统中运行的 3个不同进程。