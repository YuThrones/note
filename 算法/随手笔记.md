# 随手笔记

## 图的搜索

### 最短路径

1. Bellman-Ford算法  
循环遍历所有边，尝试用边去更新其他节点，在一次循环后没有任何更新时停止。最多更新n次，如果第n+1次还更新了，说明存在负圈，n等于节点数目。复杂度为O(|V|\*|E|)

2. Dijkstra算法  
不能用于存在负边的情况，每次只用最短距离已经确定的顶点更新其他顶点，使用堆可以达到O(|E|log|V|)的复杂度。

3. Floyd-Warshall算法  
通过简单的三重循环遍历求取任意两点的最短路距离，复杂度为O(|V|\*\*3)。

### 最小生成树
1. Prim算法  
从某个顶点出发，不断贪心选择当前树与其他顶点之间相连的最小权值的边，不断进行这个操作得到的就是最小生成树，如果使用堆复杂度为O(|E|log|V|)。

2. Kruskal算法  
将边从小到大排序，将不产生圈和重边的边加入生成树中，复杂度是O(|E|log|V|)。

### 严格弱序

* 写比较函数的时候要注意，要满足 `Strict Weak Ordering`，有三条要求:
    1. 两个关键字不能同时“严格弱序”于对方
    2. 如果a“严格弱序”于b，且b“严格弱序”于c，则a必须“严格弱序”于c
    3. 如果存在两个关键字，任何一个都不“严格弱序”于另一个，则这两个关键字是相等的。

  **注意** `<=` 和 `>=` 是不满足条件的，比较的时候不要使用。
* [Strict Weak Ordering参考资料](https://www.cnblogs.com/walkerlala/p/5561339.html)
* [Strict Weak Ordering参考资料](https://blog.csdn.net/River_Lethe/article/details/78618788)

### 最长回文串

* 使用 [Manacher's Algorithm](http://www.cnblogs.com/grandyang/p/4475985.html) 可以在O(n)的时间内解决这个问题, 这个算法本质上是一个动态规划，利用之前找到的回文串减少计算量。

### 子串匹配

* 使用[KMP算法](https://blog.csdn.net/v_july_v/article/details/7041827)可以减少回溯次数，提高效率，核心思路是寻找子串的最长公共前缀和后缀，减少不匹配时回溯的步数。KMP算法不是效率最高的，BM算法的效率更加优于KMP，而Sunday甚至可以更快。

### 对数器

* 一些算法不知道对错的时候，可以写一个暴力但是基本正确的算法用于对照，用随机数据跑多次，确保两个数据完全相等才接受答案为正确，这种做法称为对数器。

### 布隆过滤器
* 布隆过滤器可以用于类似黑名单的实现，可以解决大数据因为内存不足，无法直接使用哈希表来进行黑名单判断的问题，有效降低内存使用，缺点是会出现把非黑名单的内容认为是黑名单的问题，并且这种失误率只能降低，无法避免。 通过使用长度为m的bitmap，输入通过k个哈希函数，映射到bitmap上面k个点（可能有重复），置为1，多个输入把同一个bitmap都染色为1之后，就可以用这个来判断黑名单，只要把要比较的输入通过这k个函数哈希，并且判断对应的点位是否全部为1，即可判断是否在黑名单中（存在误判，但是可以通过取足够长的m把失误率p降到一个可以接受的范围），具体分析可以参考[布隆过滤器公式](https://blog.csdn.net/gaoyueace/article/details/90410735)。

### mirros算法
* 通过利用树的叶子结点存储信息，可以做到O(n)时间复杂度和O(1)空间复杂度遍历一棵树，并且不需要栈
  1. 开始时，把头结点赋给cur
  2. 当cur的左子树为空，cur设为右子树
  3. 当左子树不为空，把左子树的最右结点设为maxRight，如果maxRight的右节点为空，则把maxRight的右结点设为cur，然后cur设为左子树，继续遍历
  4. 当左子树的最右节点为cur，说明cur是第二次遍历了，把maxRight的最右节点设为空，然后cur设为右子树
  5. 当cur为空时遍历结束

* 可以通过一点点改造，把mirros改为前序、中序和后序遍历

### 大数据获取最高频率词

* 可以把大文件里面所有词哈希到非常多个小文件，然后每个小文件根据词频建一个堆，再把堆顶元素都拿去建一个总堆，要取k个最高词频，可以从总堆弹出堆顶，然后使用哈希找到原本这个最高词频在哪个分堆，把他从分堆弹出，再把这个分堆的堆顶放到总堆，周而复始就能找到k个最高词频。

* 大数据通用套路就是哈希分流，或者区间分流，用时间换空间。
  
### 资源限制类题目技巧
1. 哈希函数可以把数据按照种类分流
2. 布隆过滤器用于集合的建立和查询，可以节省大量空间
3. 一致性哈希解决服务器的负载均衡问题
4. 利用并查集做岛问题的并行计算
5. 位图解决某一范围上的数字出现问题，可以节省大量空间
6. 利用分段统计思想，进一步节省大量空间
7. 利用堆、外排序来做多个处理单元的结果合并