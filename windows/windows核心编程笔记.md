# Windows核心编程笔记

## 第3章 内核对象

### 3.1
* 每个内核对象只是内核分配的一个**内存块**,并且**只能由该内核访问**。该内存块是一种**数据结构**,它的成员负责维护该对象的各种信息。有些数据成员(如安全性描述符、使用计数等)在所有对象类型中是相同的,但大多数数据成员属于特定的对象类型。例如,进程对象有一个进程 I D、一个基本优先级和一个退出代码,而文件对象则拥有一个字节位移、一个共享模式和一个打开模式。

* 我们**不能直接操纵**内核对象，Windows提供了一组函数,以便用定义得很好的方法来对这些结构进行操作。这些内核对象始终都可以通过这些函数进行访问。当调用一个用于创建内核对象的函数时,该函数就返回一个用于标识该对象的句柄。该句柄可以被视为一个**不透明值**,你的**进程中的任何线程**都可以使用这个值。如果将该句柄值传递给**另一个进程**中的一个线程(使用某种形式的进程间的通信)那么这另一个进程使用你的进程的句柄值所作的调用就会**失败**。但是有3种机制,能使多个进程能够成功地**共享**单个内核对象。

* 内核对象由内核所拥有,而不是由进程所拥有。如果你的进程调用了一个创建内核对象的函数,然后你的进程终止运行,那么内核对象**不一定被撤消**。内核知道有多少进程正在使用某个内核对象,因为每个对象包含一个**使用计数**。使用计数是所有内核对象类型常用的数据成员之一。如果内核对象的使用计数降为 0,内核就撤消该对象。这样可以确保在没有进程引用该对象时系统中不保留任何内核对象。

* 内核对象能够得到**安全描述符**的保护。安全描述符用于描述谁创建了该对象,谁能够访问或使用该对象,谁无权访问该对象。用于创建内核对象的函数几乎都有一个指向 SECURITY_ATTRIBUTES结构的指针作为其参数,下面显示了CreateFileMapping函数的指针:
```
HANDLE CreateFileMapping(
	HANDLE hFile,
	PSECURITY_ATTRIBUTES psa,
	DWORD flProtect,
	DWORD dwMaximumSizeHigh,
	DWORD dwMaximumSizeLow,
	PCTSTR pszName);
```  
SECURITY_ATTRIBUTES结构类似下面的样子:  
```
typedef struct _SECURITY_ATTRIBUTES {
	DWORD nLength;
	LPVOID lpSecurityDescriptor;
	BOOL bInheritHandle;
} SECURITY_ATTRBUTES;
```
* 要确定一个对象是否属于内核对象,最容易的方法是观察创建该对象所用的函数。创建内核对象的所有函数几乎都有一个参数,你可以用来设定安全属性的信息,用于创建用户对象或GDI对象的函数都没有PSECURITY_ATTRIBUTES参数。

### 3.2
* 当一个进程被初始化时,系统要为它分配一个**句柄表**。该句柄表只用于内核对象 ,不用于用户对象或GDI对象。当进程初次被初始化时,它的句柄表是空的。每当调用一个将内核对象句柄接受为参数的函数时,就要传递由一个Create\*&函数返回的值。从内部来说,该函数要查看进程的句柄表,以获取要生成的内核对象的地址,然后按定义得很好的方式来生成该对象的数据结构。
如 果 传 递 了 一 个 无 效 索 引(句柄),该函数便返回失败,而GetLastError 则返回6(ERROR\_INVALID\_HANDLE)。由于句柄值实际上是放入进程句柄表的索引,因此这些句柄是与进程相关的,并且不能由其他进程成功地使用。

* 无论怎样创建内核对象,都要向系统指明将通过调用CloseHandle来结束对该对象的操作:  
```
BOOL CloseHandle(HANDLE hobj);
```

* 应用程序在**运行时有可能**泄漏内核对象,但是当进程终止运行时,系统将能确保所有内容均被正确地清除。另外,这个情况适用于所有对象、资源和内存块,也就是说,当进程**终止运行**时,系统将保证进程**不会留下任何对象**。

### 3.3
* 许多情况下,在不同进程中运行的线程需要共享内核对象。下面是为何需要共享的原因:  
  * 文件映射对象使你能够在同一台机器上运行的两个进程之间共享数据块。
  * 邮箱和指定的管道使得应用程序能够在连网的不同机器上运行的进程之间发送数据块。
  * 互斥对象、信标和事件使得不同进程中的线程能够同步它们的连续运行,这与一个应用程序在完成某项任务时需要将情况通知另一个应用程序的情况相同。
  
